<!doctype html>
<html lang="de">
<head>
	<meta charset="utf-8">
	<title>Metamorph-Datenmodell</title>
</head>

<body>
<h1>Das Metamorph-Datenmodell</h1>

TODO: Record ID

<p>Bevor wir uns in die Programmierung mit Metamorph stürzen können, müssen wir uns zunächst mit dem Datenmodel befassen, das hinter Metamorph steckt.
</p>

<p>Es ist eine wichtige Eigenschaft von Metamorph, dass es nicht auf die Verarbeitung eines bestimmten Datenformats wie etwa XML, Pica+, MARC21 oder JSON beschränkt ist, sondern dass beliebige semistrukturierte Datenformate verarbeitet werden können. Damit dies funktioniert, definiert Metamorph ein generisches Datenmodell.
</p>

<p>Wie sieht dieses generische Datenmodell aus? Wir nehmen als Beispiel bibliografische Informationen. Nehmen wir also an, wir haben folgende Informationen zu einem Buchtitel:
</p>

<p>Titel<br>
Autor 1, Autor 2<br>
Herausgeber<br>
Erscheinungsjahr<br>
Verlag, Ort<br>
</p>

<p>Um diese Informationen in Metamorph verarbeiten zu können, müssen sie in eine strukturierte Form gebracht werden. Die Grundlage für die Datenverarbeitung in Metamorph sind Datensätze. Die Informationen über einen Buchtitel können als so ein Datensatz betrachtet werden. In diesem Datensatz müssen die Informationen so abgelegt werden, dass wir einzele Teile benennen und auf diese Weise adressieren können. Im Metamorph-Datenmodell werden dazu sogenannte<i>Literale</i> gebildet. Dies sind einfache Schlüssel-Wert-Paare. Der Schlüssel ist der Name der Information, die als Datenwert verwendet wird. Das Datenmodell macht dabei keine Vorgaben oder Einschränkungen für die Namen der Schlüssel. Die Namen können völlig frei gewählt werden.
</p>

<pre>
title:
authors:
editor:
publicationYear:
publisher:
location:
</pre>

<p>Dies ermöglicht es bereits viele Arten von Informationen zu erfassen. Das Beispiel zeigt aber auch, dass die Literale allein einige Informationen nur sehr grob strukturiert erfassen. So sind alle Autoren in einem Literal enthalten und die Adressierung eines einzelen Autors ist nicht möglich. Im Metamorph-Datenmodell wird dieses Problem gelöst, dadurch dass Literale beliebig oft in einem Datensatz wiederholt werden können:
</p>

<pre>
title:
author:
author:
editor:
publicationYear:
publisher:
location:
</pre>

<p>Die Literale eines Datensatzes werden im Datenmodell als geordnete Menge aufgefasst. Die Reihenfolge der beiden author-Literale ist also nicht zufällig, sondern wohldefiniert und kann daher bedeutungstragend verwendet werden. Dies erlaubt es bspw. Erst- und Zweitautor zu unterscheiden, obwohl beide in einem Literal gleichen Namens abgelegt sind.
</p>

<p>An dieser Stelle sei angemerkt, dass das Metamorph-Datenmodell keine Listen- oder Array-Strukturen kennt. Solche Strukturen werden einfach durch wiederholte Literale gleichen Namens abgebildet.
</p>

<p>Bisher haben wir nur den Datensatz als Element zum Zusammenfassen von Daten kennengelernt. Durch die Wiederholbarkeit der Literale entsteht allerdings oftmals der Bedarf, Literale auch innerhalb eines Datensatz zu gruppieren, um ihre Zusammengehörigkeit auszudrücken.
</p>

<p>Angenommen wir wollen die Namen unserer Autoren in ihre einzelnen Bestandteile zerlegt im Datensatz ablegen. Mit dem bisher Vorgestellten sieht dies so aus:
</p>

<pre>
title:
authorSurname:
authorForeName:
authorSurname:
authorForename:
authorForename:
editorSurname:
editorForename:
publicationYear:
publisher:
location:
</pre>

<p>Im Vergleich zu den vorangegangenen Beispielen ist unser Datensatz durch die Aufspaltung der Namen ziemlich unübersichtlich geworden. Es ist kaum noch ersichtlich, welcher Vor- und Nachname zusammen gehören. So können z. B. Autoren und Herausgeber nur noch auseinander gehalten werden, weil die Literale unterschiedliche Namen verwenden. Diese Lösung ist allerdings nicht besonders übersichtlich und auch nicht immer möglich. Wenn die Literalnamen bspw. vorgegeben sind (Gründe dafür werden wir in Abschnitt XX kennenlernen), dann kann es sein, dass vorgegebenen Literalnamen für die Namensteile nicht zwischen Autorennamen und Herausgebernamen unterscheiden, sondern nur allgemein Vor- und Nachnamen beschreiben. Dann ist keine Unterscheidung zwischen Autoren- und Herausgebernamen mehr möglich. Im Metamorph-Datenmodell können deshalb Literale innerhalb eines Datensatzes gruppiert werden. Diese Gruppen werden <i>Entitäten</i> genannt und habe ebenso wie Literale einen beliebigen Namen, um sie adressieren und die gruppierten Inhalte unterscheiden zu können.
</p>

<pre>
title:
author:
	surname:
	foreName:
author:
	surname:
	forename:
	forename:
editor:
	surname:
	forename:
publicationYear:
publisher:
location:
</pre>

<p>Die Entitäten sind hier in der Darstellung durch Einrückungen gekennzeichnet. Du kannst dir Entitäten als eine Art von Literal mit komplexem strukturierten Inhalt oder als eine Art Datensatz im Datensatz vorstellen.
</p>

<p>Die Reihenfolge der Entitäten im Datensatz wird gemeinsam mit der Reihenfolge der Literale berücksichtigt. Es ist außerdem zulässig, denselben Namen einmal für ein Literal anschließend für eine Entität zu verwenden.
</p>

<p>Entitäten können nicht nur auf Datensatzebene zur Gruppierung von Entitäten verwendet werden, sondern auch innerhalb von Entitäten. Wenn wir bspw. für jedem Autor auch noch Informationen zu seiner Institution ablegen wollen, können wir die Informationen zur Institution in einer verschachtelten Entität ablegen, um sie zusammenzufassen:
</p>

<pre>
title:
author:
	surname:
	foreName:
	affiliation:
		institution:
		country:
author:
	surname:
	forename:
	forename:
	affiliation:
		institution:
		country:
editor:
	surname:
	forename:
	affiliation:
		institution:
		country:
publicationYear:
publisher:
location:
</pre>

<p>Auf diese Weise lassen sich mit Entitäten auch komplexe hierarchische Datensatzstrukturen abbilden.
</p>

<p>Wir haben jetzt alle Strukturelemente des Metamorph-Datenmodells kennengelernt.
TODO: Allgemeines Modell für semistrukturierte Daten
</p> 

<h1>Literal- und Entitätsnamen</h1> 

<p>Bei der Einführung der Literale habe ich bereits kurz erwähnt, dass die Literalnamen völlig beliebig sein können und dass das Metamorph-Datenmodell keinerlei Vorgaben macht, wie Namen für Literale und Entitäten zu gestalten sind. Dies ist eine wichtige Eigenschaft des Datenmodells. Es definiert nur die verfügbaren Strukturelemente (Literale und Entitäten), aber nicht wie diese kombiniert und benannt werden müssen, um Daten aus einem bestimmten Anwendungsbereich (bspw. bibliothekarische Titelaufnahmen) zu beschreiben. Dies kann je Art der Daten völlig unterschiedlich sein und ermöglicht es, Metamorph für die Verarbeitung von Daten aus verschiedensten Anwendungsbereichen einzusetzen. Voraussetzung ist nur, dass sich die Daten in einer hierarchischen Datenstruktur mit Schlüssel-Wert-Paaren abbilden lassen. 
</p>

<p>Das ist dieselbe Idee, die auch XML zugrunde liegt: Es wird eine allgemeine Struktur vorgegeben, die konkrete Ausprägung bleibt aber dem Anwender überlassen, sodass eine Nutzung in unterschiedlichsten Anwendungsbereichen möglich ist.
</p>

<p>Je nach Anwendungsfall können Literal- und Entitätsnamen ganz unterschiedlich gewählt werden. In dem Beispiel im vorigen Abschnitt habe ich einfache sprechende Namen gewählt, damit die Beispiele leicht verständlich sind. Wenn allerdings Daten verarbeitet werden sollen, die bereits in einem bestimmten domänenspezifischen Format vorliegen ist es meist sinnvoll, die Benennung und Strukturvorgaben dieses Formats zu übernehmen. So bleibt die ursprüngliche Bedeutung der Daten erhalten, trotzdem können sie aber mit Metamorph verarbeitet werden.
</p>

<p>Einer der ersten Anwendungsfälle von Metamorph war die Konversion von bibliothekarischenDaten, die im PICA+ Format vorlagen. Dieses Datenformat ist recht einfach strukturiert. Es gibt Datensätze, die jeweils bspw. einen Buchtitel oder eine Zeitschrift beschreiben. Ein Datensatz setzt sich aus sogenannten Feldern zusammen, die Angaben zu bestimmten Aspekten des beschriebenen Objekts enthalten. Da die Angaben oftmals noch eine feinere Untergliederung aufweisen, bestehen die Felder aus Unterfeldern. Felder und Unterfelder können wiederholbar sein.
</p>

<p>Das folgende Beispiel zeigt einen Auschnitt aus einem Datensatz im PICA+ Format. Die ersten vier Zeichen in jeder Zeile bezeichnen den Feldnamen. Das $-Zeichen trennt die einzelnen Unterfelder in einem Datenfeld ab. Das erste Zeichen hinter dem $-Zeichen ist der Name des Unterfelds, die restlichen Zeichen der Feldinhalt:
</p>

<pre>
003@ $0123
021A $0
</pre>

<p>Um diesen Datensatz mit Metamorph verarbeiten zu können, müssen wir die Feld-Unterfeld-Struktur des PICA+ Formats mit den Strukturelementen des Metamorph-Datenmodells nachbilden. Das PICA+ Format besitzt drei Strukturelemente: Datensatz, Feld und Unterfeld. Der Datensatz findet eine direkte Entsprechung im Datensatz des Metamorph-Datenmodells. Die Felder haben einen Namen und gruppieren mehrere Unterfelder, dies können wir mit Entitäten nachbilden. Die Unterfelder sind dagegen einfache Pärchen von Namen und Datenwert, d.h. wir können sie mit Literalen darstellen. Im Metamorph-Datenmodell sieht der obige Datensatz dann so aus: 
</p>

<pre>
003@:
	0: 123
021A:
	0: TItel
</pre>

<p>Als Datensatz-ID eignet sich bei PICA+ Datensätzen der Inhalt des Unterfelds 003@$0.
</p>

<h1>Datenformate</h1> 

<p>Neben der Trennung von Struktur und Semantik ist die zweite wichtige Eigenschaft des Metamorph-Datenmodells, dass es kein konkretes Format für die Darstellung und Ablage von Daten definiert. Der Grund dafür ist, dass sich die Datenformate in verschiedenen Anwendungsdomänen häufig stark unterscheiden. Um mit unterschiedlichen Datenformaten arbeiten zu können, definiert Metamorph nur eine Schnittstelle für das Empfangen und Senden von Datensätzen, die gemäß des Metamorph-Datenmodells strukturiert sind. Die Konstruktion dieser Datensätze aus konkreten Datenformaten ist aber in spezielle Dekodier- und Enkodiermodule ausgelagert, die unabhängig von Metamorph sind.
</p>

<p>Das Metamorph-Datenmodell geht also davon aus, dass für die Arbeit mit Daten drei Dinge notwendig sind:
</p>

<ol>
    <li>Das Datenformat: in welcher Form werden die Daten abgespeichert, eingegeben oder angezeigt?</li>
    <li>Die Datenstruktur: welche Möglichkeiten gibt es zur Strukturierung der Daten?</li>
    <li>Das Vokabular: wie sind einzelne Datenelemente benannt und wie werden sie konkret strukturiert?</li>
</ol>

<p>Diese Trennung der verschiedenen Aspekte der Datenbeschreibung findet sich in RDF wieder. RDF kann in verschiedenen Formaten serialisiert werden (u.a. RDF-XML und Turtle), es definiert eine allgemeine Datenstruktur (das RDF-Graphmodell) und es gibt Vokabulare bzw. Ontologien, die konkrete Namen und Strukturen definieren, um Domänenwissen in RDF zu beschreiben.
</p>

<p>Im Gegensatz zu RDF verwendet Metamorph ein etwas einfacheres Datenmodell und behält das Konzept des Datensatzes bei, dass es in RDF so nicht mehr gibt. Der Grund dafür ist, das sich in der täglichen Arbeit mit Daten zeigt, dass diese häufig in einer wohldefinierten Zusammenstellung benötigt werden und nicht nur in einem weitläufigen Netz.
</p>

<p>Es gibt ein Standardmodell für semistrukturierte Daten, den sogenannten Edge-labelled Graph. ... xml implementiert ihn so rdf so ... Im Metamorph-Datenmodell verwenden wir eine vereinfachte Version des Standardmodells.
</p>

- Fehlen von Verknüpfungen und Provenienzinformationen
- Keine Typinformationen. Everything is a string

<h1>Zusammenfassung</h1>

<ol>
    <li>Einfache Datenwerte werden als &ndash; Literale genannte &ndash; Schlüssel-Wert-Paare dargestellt.</li>
    <li>Literale können wiederholt werden. Im Datenmodell ist festgelegt, dass Literallisten geordnet sind.</li>
    <li>Komplexe Informationen werden mit Entitäten dargestellt. Eine Entität ist eine geordnete und benannte Menge von Literalen und anderen Entitäten.</li>
    <li>Komplexe Informationen werden mit Entitäten dargestellt. Eine Entität ist eine geordnete und benannte Menge von Literalen und anderen Entitäten.</li>
    <li>Literal- und Entitätsnamen sind nicht vergegeben. Es können beliebige Texte verwendet werden. Das Metamorph-Datenmodell legt nur die Struktur der Daten fest. Es macht keine Vorgaben zu dem verwendeten Vokabular.</li>
</ol>

</body>
</html>
