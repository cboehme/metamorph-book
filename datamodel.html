<!doctype html>
<html lang="de">
<head>
	<meta charset="utf-8">
	<title>Metamorph-Datenmodell</title>

	<link rel="stylesheet" href="layout.css" />
</head>

<body>
<h1>Das Metamorph-Datenmodell</h1>

<p>Bevor wir mit dem Schreiben von Metamorph-Skripten beginnen können, müssen wir uns zunächst mit dem Datenmodel befassen, das hinter Metamorph steckt.
</p>

<p>Es ist eine wichtige Eigenschaft von Metamorph, dass es nicht auf die Verarbeitung eines bestimmten Datenformats wie etwa XML, Pica+, MARC21 oder JSON beschränkt ist, sondern dass beliebige semistrukturierte Datenformate verarbeitet werden können. Damit dies funktioniert, definiert Metamorph ein generisches Datenmodell.
</p>

<p>Wie sieht dieses generische Datenmodell aus? Nehmen wir als Beispiel bibliografische Informationen. Angenommen, wir haben folgende Informationen zu einem Buchtitel:
</p>

<p class="Example">
Kinder- und Hausmärchen<br>
von Jacob Grimm, Wilhelm Carl Grimm<br>
Heinz Rölleke (Hrsg.)<br>
Vandenhoeck und Ruprecht, Göttingen 1986<br>
978-3-525-20764-2
</p>

<p>Um diese Informationen in Metamorph verarbeiten zu können, müssen sie in eine strukturierte Form gebracht werden. Die Grundlage für die Datenverarbeitung in Metamorph sind Datensätze. Die Informationen über einen Buchtitel können als ein Datensatz betrachtet werden. In diesem Datensatz müssen die Informationen so abgelegt werden, dass wir einzele Teile benennen und auf diese Weise adressieren können. Im Metamorph-Datenmodell werden dazu sogenannte <i>Literale</i> gebildet. Dies sind einfache Schlüssel-Wert-Paare. Der Schlüssel ist der Name der Information, die als Datenwert verwendet wird. Das Datenmodell macht dabei keine Vorgaben oder Einschränkungen für die Namen der Schlüssel; sie können völlig frei gewählt werden.
</p>

<p>Das Metamorph-Datenmodell sieht außerdem vor, dass Datensätze einen Identifikator haben. Dieser wird in Metamorph meist als <i>Datensatz-ID</i> bezeichnet und ist ein beliebiger Datenwert, der geeignet ist, einen Datensatz möglichst eindeutig zu bezeichnen. Mögliche Identifikatoren wären etwa URLs, ID-Nummern oder die ISBN-Nummer aus dem obigen Beispiel. Auch wenn es meist sinnvoll ist, einen eindeutigen Identifikator für jeden Datensatz zu verwenden, erzwingt das Datenmodell dies nicht. Man kann also auch einfach ein und denselben Wert oder sogar eine leere Zeichenfolge als Identifikator für alle Datensätze nutzen. Der verwendete Datenwert kann, muss aber nicht, zusätzlich auch als Literal im Datensatz enthalten sein, wie das Beispiel zeigt:</p>

<div class="RecordSet">
	<div class="Record">
		<span class="RecordId">Datensatz mit ID &ldquo;978-3-525-20764-2&rdquo;</span>
		<dl>
			<dt>title</dt><dd>Kinder- und Hausmärchen</dd>
			<dt>authors</dt><dd>Jacob Grimm, Wilhelm Carl Grimm</dd>
			<dt>editor</dt><dd>Heinz Rölleke</dd>
			<dt>publicationYear</dt><dd>1986</dd>
			<dt>publisher</dt><dd>Vandenhoeck und Ruprecht</dd>
			<dt>location</dt><dd>Göttingen</dd>
			<dt>isbn</dt><dd>978-3-525-20764-2</dd>
		</dl>
	</div>
</div>

<p>Dies ermöglicht es bereits viele Arten von Informationen zu erfassen. Das Beispiel zeigt aber auch, dass die Literale allein einige Informationen nur sehr grob strukturiert erfassen. So sind alle Autoren in einem Literal enthalten und die Adressierung eines einzelnen Autors ist nicht möglich. Im Metamorph-Datenmodell wird dieses Problem dadurch gelöst, dass Literale beliebig oft in einem Datensatz wiederholt werden können:
</p>

<div class="RecordSet">
	<div class="Record">
		<span class="RecordId">Datensatz mit ID &ldquo;978-3-525-20764-2&rdquo;</span>
		<dl>
			<dt>title</dt><dd>Kinder- und Hausmärchen</dd>
			<dt>author</dt><dd>Jacob Grimm</dd>
			<dt>author</dt><dd>Wilhelm Carl Grimm</dd>
			<dt>editor</dt><dd>Heinz Rölleke</dd>
			<dt>publicationYear</dt><dd>1986</dd>
			<dt>publisher</dt><dd>Vandenhoeck und Ruprecht</dd>
			<dt>location</dt><dd>Göttingen</dd>
			<dt>isbn</dt><dd>978-3-525-20764-2</dd>
		</dl>
	</div>
</div>

<h1>Datentypen</h1>

<p>Das Metamorph-Datenmodell unterscheidet anders als XML und RDF nicht zwischen verschiedenen Typen von Datenwerten. Es ist nicht möglich, festzulegen, dass ein Literal nur eine bestimmte Art von Werten &ndash; etwa nur Datumsangaben oder Zahlen &ndash; enthält. Alle Namen und Datenwerte im Metamorph-Datenmodell sind immer Zeichenfolgen. Der Hintergrund für diese Entscheidung ist, dass in bibliothekarischen Anwendungen &ndash; dem ersten Anwendungsfall von Metafacture &ndash; meist nur Textdaten Verwendung finden. Andere Datenwerte lassen sich außerdem im Normalfall leicht als Zeichenfolgen darstellen. Dies hat außerdem den Vorteil, dass die Datenverarbeitung toleranter gegenüber unsauberen Daten wird. Würde bspw. &ldquo;publicationYear&rdquo; den Datentyp Datumsangabe besitzen, könnten Datensätze, die Angaben wie "ca. 1560" oder "anno 1066" nicht mehr ohne besondere Fehlerbehandlung verarbeitet werden. Da derartige Varianzen in semistrukturierten Daten häufig vorkommen können, bietet sich die Verwendung von Zeichenfolgen als allgemeinen Datentyp an.
</p>

<p>In Abschnitt XX werden wir eine Methode beschreiben, wie man trotz dieser Beschränkung noch Typinformationen im Metamorph-Datenmodell ausdrücken (wenn auch nicht durchsetzen) kann.
</p>

<p>Die Literale eines Datensatzes werden im Datenmodell als geordnete Menge aufgefasst. Die Reihenfolge der beiden author-Literale ist also nicht zufällig, sondern wohldefiniert und kann daher bedeutungstragend verwendet werden. Dies erlaubt es bspw. Erst- und Zweitautor zu unterscheiden, obwohl beide in einem Literal gleichen Namens abgelegt sind. Das Metamorph-Datenmodell kennt keine spezielles Strukturelement für Listen. Diese werden einfach durch wiederholte Literale gleichen Namens abgebildet.
</p>

<p>Bisher haben wir nur den Datensatz als Element zum Zusammenfassen von Daten kennengelernt. Durch die Wiederholbarkeit der Literale entsteht allerdings oftmals der Bedarf, Literale auch innerhalb eines Datensatzes zu gruppieren, um ihre Zusammengehörigkeit auszudrücken.
</p>

<p>Angenommen, wir wollen die Namen unserer Autoren in ihre einzelnen Bestandteile zerlegt im Datensatz ablegen. Mit dem bisher Vorgestellten sieht dies so aus:
</p>

<div class="RecordSet">
	<div class="Record">
		<span class="RecordId">Datensatz mit ID &ldquo;978-3-525-20764-2&rdquo;</span>
		<dl>
			<dt>title</dt><dd>Kinder- und Hausmärchen</dd>
			<dt>authorSurname</dt><dd>Grimm</dd>
			<dt>authorForename</dt><dd>Jacob</dd>
			<dt>authorSurname</dt><dd>Grimm</dd>
			<dt>authorForename</dt><dd>Wilhelm</dd>
			<dt>authorForename</dt><dd>Carl</dd>
			<dt>editorSurname</dt><dd>Rölleke</dd>
			<dt>editorForename</dt><dd>Heinz</dd>
			<dt>publicationYear</dt><dd>1986</dd>
			<dt>publisher</dt><dd>Vandenhoeck und Ruprecht</dd>
			<dt>location</dt><dd>Göttingen</dd>
			<dt>isbn</dt><dd>978-3-525-20764-2</dd>
		</dl>
	</div>
</div>

<p>Im Vergleich zu den vorangegangenen Beispielen ist unser Datensatz durch die Aufspaltung der Namen ziemlich unübersichtlich geworden. Es ist kaum noch ersichtlich, welche Vor- und Nachnamen zusammen gehören. So können z.&thinsp;B. Autoren und Herausgeber nur noch auseinandergehalten werden, weil die Literale unterschiedliche Namen verwenden. Diese Lösung ist allerdings nicht besonders übersichtlich und auch nicht immer möglich. Wenn die Literalnamen bspw. vorgegeben sind (Gründe dafür werden in Abschnitt XX beschrieben), dann kann es sein, dass vorgegebene Literalnamen für die Namensteile nicht zwischen Autorennamen und Herausgebernamen unterscheiden, sondern nur allgemein Vor- und Nachnamen beschreiben. Dann ist keine Unterscheidung zwischen Autoren- und Herausgebernamen mehr möglich. Im Metamorph-Datenmodell können deshalb Literale innerhalb eines Datensatzes gruppiert werden. Diese Gruppen werden <i>Entitäten</i> genannt und habe ebenso wie Literale einen beliebigen Namen, um sie adressieren und die gruppierten Inhalte unterscheiden zu können.
</p>

<div class="RecordSet">
	<div class="Record">
		<span class="RecordId">Datensatz mit ID &ldquo;978-3-525-20764-2&rdquo;</span>
		<dl>
			<dt>title</dt><dd>Kinder- und Hausmärchen</dd>
			<dt class="Entity">author</dt>
			<dd>
				<dl>
					<dt>surname</dt><dd>Grimm</dd>
					<dt>forename</dt><dd>Jacob</dd>
				</dl>
			</dd>
			<dt class="Entity">author</dt>
			<dd>
				<dl>
					<dt>surname</dt><dd>Grimm</dd>
					<dt>forename</dt><dd>Wilhelm</dd>
					<dt>forename</dt><dd>Carl</dd>
				</dl>
			</dd>
			<dt class="Entity">editor</dt>
			<dd>
				<dl>
					<dt>surname</dt><dd>Rölleke</dd>
					<dt>forename</dt><dd>Heinz</dd>
				</dl>
			</dd>
			<dt>publicationYear</dt><dd>1986</dd>
			<dt>publisher</dt><dd>Vandenhoeck und Ruprecht</dd>
			<dt>location</dt><dd>Göttingen</dd>
			<dt>isbn</dt><dd>978-3-525-20764-2</dd>
		</dl>
	</div>
</div>

<p>Die Entitäten sind hier in der Darstellung als Boxen gezeichnet, die Literale enthalten. Man kannst sich Entitäten als eine Art von Literal mit komplexem strukturierten Inhalt oder als eine Art Datensatz im Datensatz vorstellen.
</p>

<p>Die Reihenfolge der Entitäten im Datensatz wird gemeinsam mit der Reihenfolge der Literale berücksichtigt. Es ist außerdem zulässig, denselben Namen einmal für ein Literal anschließend für eine Entität zu verwenden.
</p>

<p>Entitäten können nicht nur auf Datensatzebene zur Gruppierung von Entitäten verwendet werden, sondern auch innerhalb von Entitäten. Wenn wir bspw. für jeden Autor auch Informationen zu seiner Institution ablegen wollen, können wir die Informationen zur Institution in einer verschachtelten Entität ablegen, um sie zusammenzufassen:
</p>

<div class="RecordSet">
	<div class="Record">
		<span class="RecordId">Datensatz mit ID &ldquo;978-3-525-20764-2&rdquo;</span>
		<dl>
			<dt>title</dt><dd>Kinder- und Hausmärchen</dd>
			<dt class="Entity">author</dt>
			<dd>
				<dl>
					<dt>surname</dt><dd>Grimm</dd>
					<dt>forename</dt><dd>Jacob</dd>
					<dt class="Entity">affiliation</dt>
					<dd>
						<dl>
							<dt>institution</dt><dd>Friedrich-Wilhelms-Universität zu Berlin</dd>
							<dt>country</dt><dd>Preußen</dd>
						</dl>
					</dd>
				</dl>
			</dd>
			<dt class="Entity">author</dt>
			<dd>
				<dl>
					<dt>surname</dt><dd>Grimm</dd>
					<dt>forename</dt><dd>Wilhelm</dd>
					<dt>forename</dt><dd>Carl</dd>
					<dt class="Entity">affiliation</dt>
					<dd>
						<dl>
							<dt>institution</dt><dd>Universität Göttingen</dd>
							<dt>country</dt><dd>Königreich Hannover</dd>
						</dl>
					</dd>
				</dl>
			</dd>
			<dt class="Entity">editor</dt>
			<dd>
				<dl>
					<dt>surname</dt><dd>Rölleke</dd>
					<dt>forename</dt><dd>Heinz</dd>
				</dl>
			</dd>
			<dt>publicationYear</dt><dd>1986</dd>
			<dt>publisher</dt><dd>Vandenhoeck und Ruprecht</dd>
			<dt>location</dt><dd>Göttingen</dd>
			<dt>isbn</dt><dd>978-3-525-20764-2</dd>
		</dl>
	</div>
</div>

<p>Auf diese Weise lassen sich mit Entitäten auch komplexe hierarchische Datensatzstrukturen abbilden.
</p>

<p>Dies sind alle Strukturelemente des Metamorph-Datenmodells. Sie sind hier noch einmal kurz zusammengefasst:
</p>

<ul>
	<li>Das grundlegende Strukturelement sind <strong>Literale</strong>. Sie erlauben es einen Datenwert mit einem Namen zu versehen. Damit wird deutlich, welche Bedeutung der Datenwert hat und man kann ihn adressieren.</li>

	<li>Um komplexere Strukturen modellieren zu können, gibt es <strong>Entitäten</strong>. Entitäten fassen mehrere Literale und auch andere Entitäten zusammen. Sie sind ebenso wie Literale benannt, um die Bedeutung der in der Entität enthaltenen Literale und Entitäten auszudrücken und sie adressierbar zu machen.</li>

	<li>Der <strong>Datensatz</strong> ist das äußerste Strukturelement des Metamorph-Datenmodells. Er fasst Entitäten und Literale zusammen. Um den Datensatz identifizieren zu können, kann er mit einer Datensatz-ID versehen werden, die quasi als Name des Datensatzes fungiert.</li>
</ul>

<h2>Entitäten als Datensätze und Datensätze als Entitäten</h2>

<p>Es fällt auf, dass die Beschreibung der Funktion der Entitäten und des Datensatzes sehr ähnlich ist. In der Tat ist es so, dass sich der Datensatz von der Entität strukturell nur dadurch unterscheidet, dass er die äußere Hülle der Datenstruktur bildet. Es ist daher problemlos möglich, einen Datensatz in einen anderen als Entität einzubetten oder eine Entität aus einem Datensatz herauszuziehen und als eigenen Datensatz zu betrachten. Dabei sollte nur beachtet werden, dass sowohl Datensatz-ID als auch Entitätsname zwar beliebige Werte annehmen können, die ihnen zugeschriebene Bedeutung aber leicht unterschiedlich ist. Während die Datensatz-ID einen konkreten Datensatz bezeichnet und sich von Datensatz zu Datensatz unterscheidet, dient der Entitätsname der Identifikation einer Entität in der Datensatzstruktur und ist bei jedem Datensatz gleich. Aus diesem Grund ist es sinnvoll, beim Umwandeln eines Datensatzes in eine Entität nicht die Datensatz-ID als Entitätsname zu verwenden, sondern einen festen Namen. Andersherum sollte beim Herauslösen eines Datensatzes eine ID generiert werden, statt einfach den Entitätsnamen zu verwenden.
</p>

<p>Am Beispiel unseres Buchtitels können wir das Problem leicht nachvollziehen. Im folgenden Beispiel sind die Entitäten mit den Angaben zu den Autoren und dem Herausgeber aus dem Titeldatensatz herausgezogen und als gesonderte Personendatensätze dargestellt. Als Datensatz-IDs wurden einfach die Entitätsnamen verwendet:
</p>

<div class="RecordSet">
	<div class="Record">
		<span class="RecordId">Datensatz mit ID &ldquo;978-3-525-20764-2&rdquo;</span>
		<dl>
			<dt>title</dt><dd>Kinder- und Hausmärchen</dd>
			<dt>publicationYear</dt><dd>1986</dd>
			<dt>publisher</dt><dd>Vandenhoeck und Ruprecht</dd>
			<dt>location</dt><dd>Göttingen</dd>
			<dt>isbn</dt><dd>978-3-525-20764-2</dd>
		</dl>
	</div>
	<div class="Record">
		<span class="RecordId">Datensatz mit ID &ldquo;author&rdquo;</span>
		<dl>
			<dt>surname</dt><dd>Grimm</dd>
			<dt>forename</dt><dd>Jacob</dd>
			<dt class="Entity">affiliation</dt>
			<dd>
				<dl>
					<dt>institution</dt><dd>Friedrich-Wilhelms-Universität zu Berlin</dd>
					<dt>country</dt><dd>Preußen</dd>
				</dl>
			</dd>
		</dl>
	</div>
	<div class="Record">
		<span class="RecordId">Datensatz mit ID &ldquo;author&rdquo;</span>
		<dl>
			<dt>surname</dt><dd>Grimm</dd>
			<dt>forename</dt><dd>Wilhelm</dd>
			<dt>forename</dt><dd>Carl</dd>
			<dt class="Entity">affiliation</dt>
			<dd>
				<dl>
					<dt>institution</dt><dd>Universität Göttingen</dd>
					<dt>country</dt><dd>Königreich Hannover</dd>
				</dl>
			</dd>
		</dl>
	</div>
	<div class="Record">
		<span class="RecordId">Datensatz mit ID &ldquo;editor&rdquo;</span>
		<dl>
			<dt>surname</dt><dd>Rölleke</dd>
			<dt>forename</dt><dd>Heinz</dd>
		</dl>
	</div>
</div>

<p>Das Ergebnis zeigt, dass wir zwei Datensätze mit der ID author haben, sodass wir die Datensätze nicht mehr eindeutig identifizieren können. Ein weiterer Nachteil dieses Vorgehens ist, dass die Personen nun fest als Autoren oder Herausgeber benannt werden, obwohl dies eine Eigenschaft ist, die sie eigentlich nur im Zusammenhang mit einem Buch besitzen. Es ist ja durchaus möglich, dass etwa Jacob Grimm bei einem Buch Autor und bei einem anderen Herausgeber war. 
</p>

<p>Um diese Probleme zu vermeiden, ist es sinnvoll, beim Herauslösen der Personendatensätze die Entitätsnamen durch eindeutige Datensatz-IDs zu ersetzen. Dies erlaubt es uns nämlich auch, in dem Titeldatensatz auf diese Datensätze zu verweisen und Jacob und Wilhelm Grimm so als Autoren und Heinz Rölleke als Herausgeber zu identifizieren.</p>

<div class="RecordSet">
	<div class="Record">
		<span class="RecordId">Datensatz mit ID &ldquo;978-3-525-20764-2&rdquo;</span>
		<dl>
			<dt>title</dt><dd>Kinder- und Hausmärchen</dd>
			<dt>authorId</dt><dd>1</dd>
			<dt>authorId</dt><dd>2</dd>
			<dt>editorId</dt><dd>3</dd>
			<dt>publicationYear</dt><dd>1986</dd>
			<dt>publisher</dt><dd>Vandenhoeck und Ruprecht</dd>
			<dt>location</dt><dd>Göttingen</dd>
			<dt>isbn</dt><dd>978-3-525-20764-2</dd>
		</dl>
	</div>
	<div class="Record">
		<span class="RecordId">Datensatz mit ID &ldquo;1&rdquo;</span>
		<dl>
			<dt>surname</dt><dd>Grimm</dd>
			<dt>forename</dt><dd>Jacob</dd>
			<dt class="Entity">affiliation</dt>
			<dd>
				<dl>
					<dt>institution</dt><dd>Friedrich-Wilhelms-Universität zu Berlin</dd>
					<dt>country</dt><dd>Preußen</dd>
				</dl>
			</dd>
		</dl>
	</div>
	<div class="Record">
		<span class="RecordId">Datensatz mit ID &ldquo;2&rdquo;</span>
		<dl>
			<dt>surname</dt><dd>Grimm</dd>
			<dt>forename</dt><dd>Wilhelm</dd>
			<dt>forename</dt><dd>Carl</dd>
			<dt class="Entity">affiliation</dt>
			<dd>
				<dl>
					<dt>institution</dt><dd>Universität Göttingen</dd>
					<dt>country</dt><dd>Königreich Hannover</dd>
				</dl>
			</dd>
		</dl>
	</div>
	<div class="Record">
		<span class="RecordId">Datensatz mit ID &ldquo;3&rdquo;</span>
		<dl>
			<dt>surname</dt><dd>Rölleke</dd>
			<dt>forename</dt><dd>Heinz</dd>
		</dl>
	</div>
</div>

<p>Die Literale &ldquo;authorId&rdquo; und &ldquo;editorId&rdquo; unterscheiden sich nicht von anderen Literalen. Es liegt in den Händen des Anwenders, die Datenwerte dieser Literale als Verweise auf andere Datensätze zu interpretieren. Das Metamorph-Modell kennt kein besonderes Strukturelement für Verknüpfungen.
</p>

<p>Das Metamorph-Datenmodell mag auf den ersten Blick einfach und eingeschränkt erscheinen, es hat sich aber in der praktischen Anwendung gezeigt, dass das Datenmodell alle Strukturen abdeckt, die bei semistrukturierten Daten auftreten. Der folgende Abschnitt stellt einige Möglichkeiten vor, wie man auf einfache Weise auch spezielle Anwendungsfälle auf das Metamorph-Datenmodell abbilden kann.
</p>

<h2>Literal- und Entitätsnamen im Detail</h2> 

<p>Bei der Einführung der Literale wurde bereits kurz erwähnt, dass die Literalnamen völlig beliebig sein können und dass das Metamorph-Datenmodell keinerlei Vorgaben macht, wie Namen für Literale und Entitäten zu gestalten sind. Dies ist eine wichtige Eigenschaft des Datenmodells. Es definiert nur die verfügbaren Strukturelemente (Literale und Entitäten), aber nicht, wie diese kombiniert und benannt werden müssen, um Daten aus einem bestimmten Anwendungsbereich (bspw. bibliothekarische Titelaufnahmen) zu beschreiben. Dies kann je Art der Daten völlig unterschiedlich sein und ermöglicht es, Metamorph für die Verarbeitung von Daten aus verschiedensten Anwendungsbereichen einzusetzen. Voraussetzung ist nur, dass sich die Daten in einer hierarchischen Datenstruktur mit Schlüssel-Wert-Paaren abbilden lassen. Das ist dieselbe Idee, die auch XML zugrunde liegt: Es wird eine allgemeine Struktur vorgegeben, die konkrete Ausprägung bleibt aber dem Anwender überlassen, sodass eine Nutzung in unterschiedlichen Anwendungsbereichen möglich ist.
</p>

<p>Je nach Anwendungsfall können Literal- und Entitätsnamen unterschiedlich gewählt werden. In dem Beispiel im vorigen Abschnitt folgen die Namen bspw. keinem bestimmtem bibliothekarischen Format, sondern wurden einfach so gewählt, dass ihre Bedeutung sofort verständlich wird. Wenn allerdings Daten verarbeitet werden sollen, die bereits in einem bestimmten domänenspezifischen Format vorliegen ist es meist sinnvoll, die Benennung und Strukturvorgaben dieses Formats zu übernehmen. So bleibt die ursprüngliche Bedeutung der Daten erhalten und sie können trotzdem mit Metamorph verarbeitet werden.
</p>

<p>Die Gesamtheit der domänenspezifischen Strukturen und Benennungen, die in einem konkreten Anwendungsfall verwendet werden, bezeichnen wir in Anlehnung an die Semantic Web verwendete Terminologie als <i>Vokabular</i> bzw. <i>Ontologie</i> (im XML-Jargon würde man hingegen von einem <i>Schema</i> sprechen). Vokabulare umfassen dabei nur die in einem Anwendungsfall erlaubten Literal- und Entitätsnamen, während Ontologien auch die Festlegungen zur Strukturierung beinhalten. Die folgende Tabelle listet in der ersten Spalte das Vokabular auf, das wir in unserem obigen Beispiel verwendet haben, und in der zweiten Spalte die dazugehörige Ontologiedefinition.</p>

<table>
	<thead>
		<tr>
			<th>Vokabular</th><th>Ontologie</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><i>Datensatz</i></td>
			<td>Enthält eine oder mehrere author-Entitäten unter Berücksichtigung ihrer Reihenfolge, eine editor-Entität und je ein title-, publisherYear-, publisher-, location- und isdn-Literal</td>
		</tr>
		<tr>
			<td>author</td>
			<td>Entität, enthält ein surname-Literal und ein oder mehrere forename-Literale</td>
		</tr>
		<tr>
			<td>editor</td>
			<td>Entität, enthält ein surname-Literal und ein oder mehrere forename-Literale</td>
		</tr>
		<tr>
			<td>title</td><td>Literal</td>
		</tr>
		<tr>
			<td>publisherYear</td><td>Literal</td>
		</tr>
		<tr>
			<td>publisher</td><td>Literal</td>
		</tr>
		<tr>
			<td>location</td><td>Literal</td>
		</tr>
		<tr>
			<td>isbn</td><td>Literal</td>
		</tr>
		<tr>
			<td>surname</td>
			<td>Literal</td>
		</tr>
		<tr>
			<td>forename</td>
			<td>Literal</td>
		</tr>
	</tbody>
</table>

<h1>Strukturierte Literal- und Entitätsnamen</h1>

<p>Manchmal gibt es zusätzliche Informationen zu einem Literal, die für die Arbeit mit dem Literal hilfreich sind und die deshalb in der Datenmodellierung enthalten sein sollten. Solche Informationen können bspw. Angaben zur Sprache oder zum Datentyp eines Literalwerts sein oder ein Hinweis darauf, dass der Literalwert ein Verweis auf einen anderen Datensatz ist. Eine Möglichkeit, solche Informationen in die Daten zu integrieren, ist die Nutzung einer Entität statt eines Literals, innerhalb derer dann der eigentliche Datenwert und die Zusatzinformationen in mehreren Literalen abgelegt sind. Auf diese Weise könnten wir Sprachangaben zu dem Literal <code>title: Grimms' Fairy Tales</code> in folgender Form darstellen:</p>

<div class="RecordSnippet">
	<dl>
		<dt class="Entity">title</dt>
		<dd>
			<dl>
				<dt>value</dt><dd>Grimms' Fairy Tales</dd>
				<dt>language</dt><dd>en</dd>
			</dl>
		</dd>
	</dl>
</div>

<p>Das value-Literal entspricht hier dem ursprünglichen Wert des title-Literals, und die Zusatzinformation zur Sprache ist als zusätzliches Literal in der Entität enthalten. Die Entität selbst wird dann anstelle des ursprünglichen title-Literals verwendet.
</p>

<p>Diese Lösung erfüllt ihren Zweck, hat allerdings den Nachteil, die Struktur des Datensatzes deutlich zu verändern. Dies ist nicht immer gewünscht, insbesondere wenn die Zusatzinformationen eigentlich recht kompakt sind, wie es etwa bei Sprachangaben oder Verknüpfungshinweisen der Fall ist. Eine Möglichkeit, zu einer kompakteren Darstellung zu kommen, ist die Verwendung strukturierter Literal- und Entitätsnamen. So könnten wir im obigen Beispiel einfach festlegen, dass an einen Literalnamen ein @-Zeichen gefolgt von einem Sprachcode angehängt werden kann, um die Sprache des Datenwerts anzugeben. Unser title-Literal sähe dann wie folgt aus: <code>title@en: Grimms' Fairy Tales</code>.
</p>

<p>Andere Varianten von strukturierten Namen, die wir bereits in Metafacture eingesetzt haben, sind das Voranstellen eines *-Zeichens, um URLs zu markieren, oder eines ~-Zeichens, um Literale zu kennzeichnen, die als XML-Attribute zu behandeln sind. Eine interessante Variante ist auch die Verwendung von [] als Suffix für Entitätsnamen in der JSON-Verarbeitung, um anzudeuten, dass der Inhalt der Entität als Array aufzufassen ist und die Namen der Elemente keine Bedeutung tragen. Das folgende Beispiel zeigt die Verwendung des Konstrukts, um ein Array mit drei Elementen zu modellieren:
</p>

<div class="RecordSnippet">
	<dl>
		<dt class="Entity">arrayEntity[]</dt>
		<dd>
			<dl>
				<dt>ignoredName</dt><dd>Erster Datenwert</dd>
				<dt>ignoredName</dt><dd>Zweiter Datenwert</dd>
				<dt>ignoredName</dt><dd>Dritter Datenwert</dd>
			</dl>
		</dd>
	</dl>
</div>

<p>Die Integration von Zusatzinformationen in die Literal- und Entitätsnamen ist eine einfache und vielseitige Technik. Ihre Verwendung ist nicht immer offensichtlich und die Bedeutung verschiedener Angaben in den Namen ist nicht immer selbsterklärend. Außerdem kann es notwendig werden, im Zuge der Datenverarbeitung die Zusatzinformationen wieder aufwändig aus den Namen herauszutrennen. Bei komplexeren Zusatzinformationen sollte man daher die oben beschriebene Entitäten-Methode der strukturierten Benennung vorziehen. Für Kleinigkeiten wie Hinweise auf Verweise, ist sie jedoch oft optimal.
</p>

<h2>Datenformate</h2> 

<p>Die im vorhergehenden Abschnitt beschriebene Trennung von Strukturelementen und Vokabular bzw. Ontologie ist eine Voraussetzung, um das Metamorph-Datenmodell in verschiedenen Anwendungsbereichen nutzen zu können. Die zweite Voraussetzung ist die Möglichkeit verschiedenste Datenformate für die Ein- und Ausgabe verwenden zu können. Aus diesem Grund sind auch die Beispiele in diesem Kapitel grafisch dargestellt und nicht als formatierter Text: Es gibt kein festgelegtes Format für die Darstellung oder Serialisierung von Datensätzen im Metamorph-Datenmodell.  
</p>

<p>Um das Metamorph-Datenmodell praktisch einsetzen zu können, muss es aber natürlich möglich sein, Daten darstellen und vor allem ein- und auslesen (also serialisieren und deserialisieren) zu können. 
<!-- TODO: hier weiterschreiben -->
Um mit unterschiedlichen Datenformaten arbeiten zu können, definiert Metamorph nur eine Schnittstelle für das Empfangen und Senden von Datensätzen, die gemäß des Metamorph-Datenmodells strukturiert sind. Die Konstruktion dieser Datensätze aus konkreten Datenformaten ist aber in spezielle Dekodier- und Enkodiermodule ausgelagert, die unabhängig von Metamorph sind.
</p>

<h3>Das Formeta-Format</h3>

<p>Wir haben gesehen, dass bei den meisten Datenformaten berücksichtigt werden muss, dass sie keine eins-zu-eins Abbildung der Strukturelemente des Metamorph-Datenmodells erlauben. Oft umfassen einzelne Datenformate nicht den vollen Umfang des Datenmodells, sondern beschränken einige Eigenschaften wie bspw. die erlaubte Verschachtelungstiefe von Entitäten oder ähnliches, sodass nicht alle Datenstrukturen in dem jeweiligen Format abgebildet werden können. Teilweise gibt es auch mehrere Varianten, wie ein Strukturelement eines Datenformats im Metamorph-Datenmodell abgebildet werden kann. Dies betrifft z.&thinsp;B. oft die Darstellbarkeit von Listen oder Arrays. Da es in der Praxis häufig hilfreich ist, Daten direkt im Metamorph-Datenmodell anzeigen oder ablegen zu können, ohne sich Gedanken über die Fähigkeiten eines Formats machen zu müssen, haben wir in Metafacture ein eigenes Datenformat namens <span class="Footnote" title="Formeta ist ein Wortspiel aus dem Wort Format und dem Englischen &ldquo;for meta&rdquo; d.&thinsp;h. für Metadaten."><i>Formeta</i>-Format</span> integriert. Dieses Datenformat wurde passend zum Metamorph-Datenmodell entworfen, sodass es alle in dem Datenmodell möglichen Datenstrukturen kompakt abbilden kann. Eigentlich hätte ich die Datensätze in diesem Kapitel statt als Grafiken auch im Formeta-Format zeigen können. Ich habe aber darauf verzichtet, um deutlich zu machen, dass das Metamorph-Datenmodell keine bestimmte Serialisierungsform besitzt, sondern losgelöst davon definiert ist.
</p>

<p>Das Formeta-Format ist sehr einfach aufgebaut, hat aber eine flexible Syntax, sodass wir Daten sowohl sehr kompakt als auch übersichtlich formatiert ausgeben können. Beim Entwurf der Syntax wurde außerdem darauf geachtet, dass auch eine händische Eingabe von Daten möglichst einfach ist.
</p>

<p>Es gibt nur zwei Elemente im Formeta-Format: Literale und Gruppen. Erstere entsprechen den Literalen des Metamorph-Datenmodells, Letztere werden für die Formatierung von Datensätzen und Entitäten verwendet. Das hat den Vorteil, dass es dadurch sehr einfach wird, die oben beschriebene Technik, Datensätze als Entitäten in andere Datensätze einzubetten, anzuwenden. Durch die völlig gleiche Darstellung kann die Anwenderin flexibel entscheiden, ob die äußerste Gruppe als Datensatz oder Entität zu verstehen ist.
</p>

<p>Das folgende Syntaxdiagram stellt die Grundstruktur des Formeta-Formats dar:
</p>

<figure id="formetaGruppe">
	<img src="formeta-gruppe.svg" />
	<img src="formeta-name-wert.svg" />
	<img src="formeta-text-in-af.svg" />
	<img src="formeta-text.svg" />
	<img src="formeta-leerraum.svg" >
	<img src="formeta-esc-sequenz.svg" />
	<img src="formeta-zeichen.svg" />
	<img src="formeta-zeichen-in-af.svg" />
	<figcaption>Schmematische Darstellung des Formeta-Formats.</figcaption>
</figure>

<!--
Namen und Werte können auf zwei Arten im Formeta-Format dargestellt werden. Entweder als Text in Anführungszeichen oder als Text ohne Anführungszeichen. Die Verwendung von Anführungszeichen reduziert die Anzahl der Zeichen, die maskiert werden müssen. Vor und nach einem Namen oder Wert darf beliebiger Leerraum vorhanden sein. Das Diagramm zeigt auch, dass leere Namen und Werte zulässig sind. -->
<!-- Hier muss der Übergang noch verbessert werden -->

<p>Ein Literal sind einfach zwei durch einen Doppelpunkt in Literalname und Literalwert aufgeteilte Texte:
</p>

<pre class="Example">
title: Kinder- und Hausmärchen
</pre>

<p>Eine Gruppe besteht aus dem Gruppennamen &ndash; dies ist entweder der Entitätsname oder die Datensatz-ID &ndash; gefolgt von einer Liste von Literalen und Gruppen in geschweiften Klammern. Innerhalb der Liste sind die Literale und Gruppen mit Kommata getrennt:
</p>

<pre class="Example">
author{	
	surname: Grimm,
	forename: Jacob,
	affiliation{ institution: Friedrich-Wilhelms-Universität zu Berlin },
	birthdate: 1786-01-04
}
</pre>

<p>Damit haben wir die Grundstrukturen des Formeta-Formats kennengelernt und können uns nun einigen Feinheiten zuwenden
</p>

<h2>Beispiele für die Darstellung verschiedener Formate im Metamorph-Datenmodell</h2>

<p>Im Folgenden zeige ich wie verschiedene bekannte Datenformate im Metamorph-Datenmodell abgebildet werden können. Wir beginnen mit einem einfachen Datenformat aus dem Bibliotheksbereich und beschäftigen und anschließend mit XML, JSON und RDF. Diese Formate sind besonders interessant, da sie ebenfalls zur Erfassung beliebiger semistrukturierter Daten entwickelt wurden. Ihre Datenmodelle sind allerdings alle leicht unterschiedlich und unterscheiden sich auch vom Metamorph-Datenmodell. Wir werden aber sehen, dass es dennoch möglich ist, beliebig strukturierte Daten aus diesen Formate im Metamorph-Datenmodell zu modellieren. Dies zeit, dass sich jegliche in JSON, XML und RDF vorliegenden Daten mit Metamorph verarbeiten lassen.
</p>

<h3>Darstellung von PICA+ im Metamorph-Datenmodell</h3>

<p>Einer der ersten Anwendungsfälle von Metamorph war die Konversion von bibliothekarischen Daten, die im PICA+ Format vorlagen. Dieses Datenformat ist recht einfach strukturiert. Es gibt Datensätze, die jeweils bspw. einen Buchtitel oder eine Zeitschrift beschreiben. Ein Datensatz setzt sich aus sogenannten Feldern zusammen, die Angaben zu bestimmten Aspekten des beschriebenen Objekts enthalten. Da die Angaben oftmals noch eine feinere Untergliederung aufweisen, bestehen die Felder aus Unterfeldern. Felder und Unterfelder können wiederholbar sein. Bei gleichnamigen Feldern garantiert PICA+ keine bestimmte Reihenfolge dieser Felder. Wenn dies Notwendig ist, kann der Feldname um eine sogenannte <i>Occurrence</i> ergänzt werden. Dabei handelt es sich um einen Index, der an den Feldnamen angehängt wird und die Position des Feldes beschreibt.
</p>

<p>Das folgende Beispiel zeigt einen Auschnitt aus einem Datensatz im PICA+ Format. Die ersten vier Zeichen in jeder Zeile bezeichnen den Feldnamen, eine ggf. vorhandene <i>Occurrence</i> besteht aus zwei Ziffern, die mit einem Schrägstrich vom Feldnamen abgetrennt sind. Das $-Zeichen trennt die einzelnen Unterfelder in einem Datenfeld ab. Das erste Zeichen hinter dem $-Zeichen ist der Name des Unterfelds, die restlichen Zeichen sind der eigentliche Inhalt des Unterfelds:<a href="#footnote-1">1</a>
</p>

<section id="footnote-1">
	Die genannten Sonderzeichen für die Kennzeichnung von Feldern und Unterfeldern sind die für die Darstellung in PICA-Systemen verwendeten. In den eigentlichen Daten werden stattdessen . Beim PICA+ Format wird zwischen dem Intern- und dem Externformat unterschieden. Diese beiden Formate unterscheiden sich nur in den verwendeten Feld- und Unterfeldnamen. Ich verwende hier die Feldnamen des Internformats. 
</section>

<pre class="Example">
003@ $0123
021A $0
028A/01
028A/02
TODO: Beispiel kompletieren
</pre>

<p>Um diesen Datensatz mit Metamorph verarbeiten zu können, müssen wir die Feld-Unterfeld-Struktur des PICA+ Formats mit den Strukturelementen des Metamorph-Datenmodells nachbilden. Das PICA+ Format besitzt drei Strukturelemente: Datensatz, Feld und Unterfeld. Diese Elemente können wie folgt auf das Metamorph-Datenmodell abgebildet werden:
</p>

<ul>
	<li>Der <strong>PICA+ Datensatz</strong> findet eine direkte Entsprechung im Datensatz des Metamorph-Datenmodells. Als Datensatz-Identifikator kann der Inhalt des Unterfelds 003@$0 verwendet werden. In diesem Unterfeld steht bei PICA+ gängigerweise eine eindeutige Datensatznummer.</li>

	<li>Ein <strong>PICA+ Feld</strong> hat einen Namen und gruppiert ein oder mehrere Unterfelder. Dies können wir mit einer Entität nachbilden. Die ggf. vorhandenen Angaben zu <i>Occurrences</i> benötigen wir nicht, da die Reihenfolge der Entitäten im Metamorph-Datenmodell immer beachtet wird. Wir betrachten die <i>Occurrence</i> daher einfach als Teil des Feldnamens. Alternativ wäre es auch möglich, sie vom Feldnamen abzuschneiden und zu verwerfen.</li>
	
	<li>Ein <strong>Unterfeld</strong> ist einfach ein Pärchen von Namen und Datenwert, wir können es also einfach als ein Literal darstellen.</li>
</ul>

<p>Im Metamorph-Datenmodell sieht der obige Datensatz dann so aus: 
</p>

<div class="RecordSet">
	<div class="Record">
		<span class="RecordId">Datensatz mit Id &ldquo;123&rdquo;</span>
		<dl>
			<dt class="Entity">003@</dt>
			<dd>
				<dl>
					<dt>0</dt><dd>123</dd>
				</dl>
			</dd>
			<dt class="Entity">021A</dt>
			<dd>
				<dl>
					<dt>0</dt><dd>Titel</dd>
				</dl>
			</dd>
		</dl>
	</div>
</div>

<p>Das Beispiel zeigt, dass sich außer den Strukturelementen zur Gliederung des Datensatzes durch die Umwandlung ins Metamorph-Datenmodell nichts an dem Datensatz geändert hat, was seine Bedeutung verändert. Auf die gleich Art und Weise können auch andere Datenformate aus dem bibliothekarischen Bereich wie etwa MARC21 ins Metamorph-Datenmodel übertragen werden.</p>

<h3>Darstellung von JSON im Metamorph-Datenmodell</h3>

<h3>Darstellung von XML im Metamorph-Datenmodell</h3>

<h3>Darstellung von RDF im Metamorph-Datenmodell</h3>

<p>Im Gegensatz zu RDF verwendet Metamorph ein etwas einfacheres Datenmodell und behält das Konzept des Datensatzes bei, dass es in RDF so nicht mehr gibt. Der Grund dafür ist, das sich in der täglichen Arbeit mit Daten zeigt, dass diese häufig in einer wohldefinierten Zusammenstellung benötigt werden und nicht nur in einem weitläufigen Netz.
</p>

<p>Diese Trennung der verschiedenen Aspekte der Datenbeschreibung findet sich in RDF wieder. RDF kann in verschiedenen Formaten serialisiert werden (u.&thinsp;a. RDF-XML und Turtle), es definiert eine allgemeine Datenstruktur (das RDF-Graphmodell) und es gibt Vokabulare bzw. Ontologien, die konkrete Namen und Strukturen definieren, um Domänenwissen in RDF zu beschreiben.
</p>

<h2>Zusammenfassung</h2>

<p>Das Metamorph-Datenmodell geht also davon aus, dass für die Arbeit mit Daten drei Dinge notwendig sind:
</p>

<ol>
    <li>Das Datenformat: in welcher Form werden die Daten abgespeichert, eingegeben oder angezeigt?</li>
    <li>Die Datenstruktur: welche Möglichkeiten gibt es zur Strukturierung der Daten?</li>
    <li>Das Vokabular: wie sind einzelne Datenelemente benannt und wie werden sie konkret strukturiert?</li>
</ol>

<ol>
    <li>Einfache Datenwerte werden als &ndash; Literale genannte &ndash; Schlüssel-Wert-Paare dargestellt.</li>
    <li>Literale können wiederholt werden. Im Datenmodell ist festgelegt, dass Literallisten geordnet sind.</li>
    <li>Komplexe Informationen werden mit Entitäten dargestellt. Eine Entität ist eine geordnete und benannte Menge von Literalen und anderen Entitäten.</li>
    <li>Komplexe Informationen werden mit Entitäten dargestellt. Eine Entität ist eine geordnete und benannte Menge von Literalen und anderen Entitäten.</li>
    <li>Literal- und Entitätsnamen sind nicht vergegeben. Es können beliebige Texte verwendet werden. Das Metamorph-Datenmodell legt nur die Struktur der Daten fest. Es macht keine Vorgaben zu dem verwendeten Vokabular.</li>
</ol>

</body>
</html>
