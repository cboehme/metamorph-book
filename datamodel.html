<!doctype html>
<html lang="de">
<head>
	<meta charset="utf-8">
	<title>Metamorph-Datenmodell</title>

	<link rel="stylesheet" href="layout.css" />
	<script src="hyphenate.js" type="text/javascript"></script>
</head>

<body class="Hyphenated">

<h1>Das Metamorph-Datenmodell</h1>

<p>Bevor wir mit dem Schreiben von Metamorph-Skripten beginnen können, müssen wir uns zunächst mit dem Datenmodel befassen, das hinter Metamorph steckt.
</p>

<p>Es ist eine wichtige <strong>Eigenschaft von Metamorph</strong>, dass es nicht auf die Verarbeitung eines bestimmten Datenformats wie etwa XML, Pica+, MARC21 oder JSON beschränkt ist, sondern dass beliebige semistrukturierte Datenformate verarbeitet werden können. Damit dies funktioniert, definiert Metamorph ein generisches Datenmodell. D.&thinsp;h. ein Datenmodell, das nicht auf ein bestimmtes Datenformats zugeschnitten ist, sondern so allgemein formuliert ist, dass verschiedenste Datenformate in dem Datenmodell abgebildet werden können.
</p>

<p>Wie sieht das <strong>generische Datenmodell</strong> von Metamorph aus? Verwenden wir als Beispiel bibliografische Daten. Angenommen, wir haben folgende Informationen zu einem Buchtitel:
</p>

<p class="Example">
Kinder- und Hausmärchen<br>
von Jacob Grimm und Wilhelm Carl Grimm<br>
Heinz Rölleke (Hrsg.)<br>
Vandenhoeck und Ruprecht, Göttingen 1986<br>
978-3-525-20764-2
</p>

<p>Um diese Informationen in Metamorph verarbeiten zu können, müssen sie in eine strukturierte Form gebracht werden. Die Grundlage für die Datenverarbeitung in Metamorph sind Datensätze. Die Informationen über einen Buchtitel können als ein Datensatz betrachtet werden. In diesem Datensatz müssen die Informationen so abgelegt werden, dass wir einzelne Teile benennen und auf diese Weise gezielt auswählen können. Im Metamorph-Datenmodell werden dazu sogenannte <strong><dfn>Literale</dfn></strong> gebildet. Dies sind einfache Schlüssel-Wert-Paare. Der Schlüssel ist der Name der Information, die als Datenwert verwendet wird. Das Datenmodell macht dabei keine Vorgaben oder Einschränkungen für die Namen der Schlüssel; sie können völlig frei gewählt werden.
</p>

<p>Das Metamorph-Datenmodell sieht außerdem vor, dass Datensätze einen Identifikator haben. Dieser wird in Metamorph meist als <strong><dfn>Datensatz-ID</dfn></strong> bezeichnet und ist ein beliebiger Datenwert, der geeignet ist, einen Datensatz möglichst eindeutig zu bezeichnen. Mögliche Identifikatoren wären etwa URLs, ID-Nummern aus einer Datenbank oder die ISBN-Nummer aus dem obigen Beispiel. Auch wenn es meist sinnvoll ist, einen eindeutigen Identifikator für jeden Datensatz zu verwenden, erzwingt das Datenmodell dies nicht. Man kann also auch einfach ein und denselben Wert oder sogar eine leere Zeichenfolge als Identifikator für alle Datensätze nutzen. Der verwendete Datenwert kann, muss aber nicht, zusätzlich auch als Literal im Datensatz enthalten sein, wie das Beispiel zeigt:</p>

<div class="RecordSet">
	<div class="Record">
		<span class="RecordId">Datensatz mit ID &ldquo;978-3-525-20764-2&rdquo;</span>
		<dl>
			<dt>title</dt><dd>Kinder- und Hausmärchen</dd>
			<dt>authors</dt><dd>Jacob Grimm, Wilhelm Carl Grimm</dd>
			<dt>editor</dt><dd>Heinz Rölleke</dd>
			<dt>publicationYear</dt><dd>1986</dd>
			<dt>publisher</dt><dd>Vandenhoeck und Ruprecht</dd>
			<dt>location</dt><dd>Göttingen</dd>
			<dt>isbn</dt><dd>978-3-525-20764-2</dd>
		</dl>
	</div>
</div>

<p>Dies ermöglicht es bereits viele Arten von Informationen zu erfassen. Das Beispiel zeigt aber auch, dass die Literale einige Informationen nur sehr grob strukturiert erfassen. So sind alle Autoren in einem einzigen Literal enthalten und innerhalb des Literalwerts nur textlich durch Kommata voneinander getrennt. Ein einzelner Autorenname kann so nicht gezielt ausgewählt werden; dazu müsste jeder Autor in einem eigenen Literal abgelegt sein. Um dies möglichst einfach zu machen, erlaubt es das Metamorph-Datenmodell, in einem Datensatz <strong>Literalnamen mehrfach zu verwenden</strong>:
</p>

<div class="RecordSet">
	<div class="Record">
		<span class="RecordId">Datensatz mit ID &ldquo;978-3-525-20764-2&rdquo;</span>
		<dl>
			<dt>title</dt><dd>Kinder- und Hausmärchen</dd>
			<dt>author</dt><dd>Jacob Grimm</dd>
			<dt>author</dt><dd>Wilhelm Carl Grimm</dd>
			<dt>editor</dt><dd>Heinz Rölleke</dd>
			<dt>publicationYear</dt><dd>1986</dd>
			<dt>publisher</dt><dd>Vandenhoeck und Ruprecht</dd>
			<dt>location</dt><dd>Göttingen</dd>
			<dt>isbn</dt><dd>978-3-525-20764-2</dd>
		</dl>
	</div>
</div>

<p>Im Beispiel wurde das <var>authors</var>-Literal in zwei Literale zerlegt, die jeweils einen Autor repräsentieren. Dank der Möglichkeit, Literalnamen beliebig zu wiederholen, können beide Literale den Namen <var>author</var> tragen, und es ist nicht nötig, künstliche Unterscheidungen etwa durch eine angehängte Nummerierung vorzunehmen.
</p>

<p>Die Literale eines Datensatzes werden im Datenmodell als <strong>geordnete Menge</strong> aufgefasst. Die Reihenfolge der beiden <var>author</var>-Literale ist also nicht zufällig, sondern wohldefiniert und kann daher bedeutungstragend verwendet werden. Dies erlaubt es bspw. Erst- und Zweitautor zu unterscheiden, obwohl beide in einem Literal gleichen Namens abgelegt sind. Das Metamorph-Datenmodell kennt keine spezielles Strukturelement für Listen. Diese werden einfach durch wiederholte Literale gleichen Namens abgebildet.
</p>

<h2>Entitäten</h2>

<p>Bisher haben wir nur den Datensatz als Element zum Zusammenfassen von Daten kennengelernt. Durch die Wiederholbarkeit der Literale entsteht allerdings oftmals der Bedarf, Literale auch innerhalb eines Datensatzes zu gruppieren, um ihre Zusammengehörigkeit auszudrücken.
</p>

<p>Angenommen, wir wollen die Namen unserer Autoren in ihre einzelnen Bestandteile zerlegt im Datensatz ablegen. Mit dem bisher Vorgestellten sieht dies so aus:
</p>

<div class="RecordSet">
	<div class="Record">
		<span class="RecordId">Datensatz mit ID &ldquo;978-3-525-20764-2&rdquo;</span>
		<dl>
			<dt>title</dt><dd>Kinder- und Hausmärchen</dd>
			<dt>authorSurname</dt><dd>Grimm</dd>
			<dt>authorForename</dt><dd>Jacob</dd>
			<dt>authorSurname</dt><dd>Grimm</dd>
			<dt>authorForename</dt><dd>Wilhelm</dd>
			<dt>authorForename</dt><dd>Carl</dd>
			<dt>editorSurname</dt><dd>Rölleke</dd>
			<dt>editorForename</dt><dd>Heinz</dd>
			<dt>publicationYear</dt><dd>1986</dd>
			<dt>publisher</dt><dd>Vandenhoeck und Ruprecht</dd>
			<dt>location</dt><dd>Göttingen</dd>
			<dt>isbn</dt><dd>978-3-525-20764-2</dd>
		</dl>
	</div>
</div>

<p>Im Vergleich zu den vorangegangenen Beispielen ist unser Datensatz durch die Aufspaltung der Namen ziemlich unübersichtlich geworden. Es ist kaum noch ersichtlich, welche Vor- und Nachnamen zusammen gehören. So können z.&thinsp;B. Autoren und Herausgeber nur noch auseinandergehalten werden, weil die Literale unterschiedliche Namen verwenden. Diese Lösung ist allerdings nicht besonders übersichtlich und auch nicht immer möglich. Wenn die Literalnamen bspw. vorgegeben sind (Gründe dafür werden in Abschnitt <a href="#nameDetails">Vokabulare und Ontologien für Literale und Entitäten</a> beschrieben), kann es sein, dass die vorgegebenen Literalnamen für die Namensteile nicht zwischen Autorennamen und Herausgebernamen unterscheiden, sondern nur allgemein Vor- und Nachnamen beschreiben. Dann ist keine Unterscheidung zwischen Autoren- und Herausgebernamen mehr möglich. Im Metamorph-Datenmodell können deshalb Literale innerhalb eines Datensatzes gruppiert werden. Diese Gruppen werden <strong><dfn>Entitäten</dfn></strong> genannt und habe ebenso wie Literale einen beliebigen Namen, um sie gezielt auswählen und die gruppierten Inhalte unterscheiden zu können.
</p>

<div class="RecordSet">
	<div class="Record">
		<span class="RecordId">Datensatz mit ID &ldquo;978-3-525-20764-2&rdquo;</span>
		<dl>
			<dt>title</dt><dd>Kinder- und Hausmärchen</dd>
			<dt class="Entity">author</dt>
			<dd>
				<dl>
					<dt>surname</dt><dd>Grimm</dd>
					<dt>forename</dt><dd>Jacob</dd>
				</dl>
			</dd>
			<dt class="Entity">author</dt>
			<dd>
				<dl>
					<dt>surname</dt><dd>Grimm</dd>
					<dt>forename</dt><dd>Wilhelm</dd>
					<dt>forename</dt><dd>Carl</dd>
				</dl>
			</dd>
			<dt class="Entity">editor</dt>
			<dd>
				<dl>
					<dt>surname</dt><dd>Rölleke</dd>
					<dt>forename</dt><dd>Heinz</dd>
				</dl>
			</dd>
			<dt>publicationYear</dt><dd>1986</dd>
			<dt>publisher</dt><dd>Vandenhoeck und Ruprecht</dd>
			<dt>location</dt><dd>Göttingen</dd>
			<dt>isbn</dt><dd>978-3-525-20764-2</dd>
		</dl>
	</div>
</div>

<p>Die Entitäten sind hier in der Darstellung als Boxen gezeichnet, die Literale enthalten. Man kann sich Entitäten als eine Art von Literal mit strukturiertem Inhalt oder als eine Art Datensatz im Datensatz vorstellen.
</p>

<p>Die <strong>Reihenfolge der Entitäten</strong> im Datensatz wird gemeinsam mit der Reihenfolge der Literale berücksichtigt. Es ist außerdem zulässig, einem Literal und einer Entität denselben Namen zu geben. Die Wiederholbarkeit der Namen ist unabhänigig davon, ob es sich um Literale oder Entitäten handelt.
</p>

<p>Entitäten können nicht nur auf Datensatzebene zur Gruppierung von Literalen verwendet werden, sondern auch innerhalb von Entitäten. Wenn wir bspw. für jeden Autor auch Informationen zu seiner Institution ablegen wollen, können wir die Informationen zur Institution in einer <strong>verschachtelten Entität</strong> ablegen, um sie zusammenzufassen:
</p>

<div class="RecordSet">
	<div class="Record">
		<span class="RecordId">Datensatz mit ID &ldquo;978-3-525-20764-2&rdquo;</span>
		<dl>
			<dt>title</dt><dd>Kinder- und Hausmärchen</dd>
			<dt class="Entity">author</dt>
			<dd>
				<dl>
					<dt>surname</dt><dd>Grimm</dd>
					<dt>forename</dt><dd>Jacob</dd>
					<dt class="Entity">affiliation</dt>
					<dd>
						<dl>
							<dt>institution</dt><dd>Friedrich-Wilhelms-Universität zu Berlin</dd>
							<dt>country</dt><dd>Preußen</dd>
						</dl>
					</dd>
				</dl>
			</dd>
			<dt class="Entity">author</dt>
			<dd>
				<dl>
					<dt>surname</dt><dd>Grimm</dd>
					<dt>forename</dt><dd>Wilhelm</dd>
					<dt>forename</dt><dd>Carl</dd>
					<dt class="Entity">affiliation</dt>
					<dd>
						<dl>
							<dt>institution</dt><dd>Universität Göttingen</dd>
							<dt>country</dt><dd>Königreich Hannover</dd>
						</dl>
					</dd>
				</dl>
			</dd>
			<dt class="Entity">editor</dt>
			<dd>
				<dl>
					<dt>surname</dt><dd>Rölleke</dd>
					<dt>forename</dt><dd>Heinz</dd>
				</dl>
			</dd>
			<dt>publicationYear</dt><dd>1986</dd>
			<dt>publisher</dt><dd>Vandenhoeck und Ruprecht</dd>
			<dt>location</dt><dd>Göttingen</dd>
			<dt>isbn</dt><dd>978-3-525-20764-2</dd>
		</dl>
	</div>
</div>

<p>Auf diese Weise lassen sich mit Entitäten auch komplexe hierarchische Datensatzstrukturen abbilden.
</p>

<h2>Zusammenfassung</h2>

<p>Damit sind alle Strukturelemente des Metamorph-Datenmodells beschrieben. Hier sind sie noch einmal kurz zusammengefasst:
</p>

<ul>
	<li>Das grundlegende Strukturelement sind <strong>Literale</strong>. Sie erlauben es einen Datenwert mit einem Namen zu versehen. Dieser macht die Bedeutung des Datenwert deutlich und dient dazu, den Datenwert gezielt auswählen zu können.</li>

	<li>Um komplexere Strukturen modellieren zu können, gibt es <strong>Entitäten</strong>. Entitäten fassen mehrere Literale und auch andere Entitäten zusammen. Sie sind ebenso wie Literale benannt, um die Bedeutung der in der Entität enthaltenen Literale und Entitäten auszudrücken und sie auswählbar zu machen.</li>

	<li>Der <strong>Datensatz</strong> ist das äußerste Strukturelement des Metamorph-Datenmodells. Er fasst Entitäten und Literale zusammen. Um den Datensatz identifizieren zu können, kann er mit einer Datensatz-ID versehen werden, die quasi als Name des Datensatzes fungiert.</li>
</ul>

<p>Das Metamorph-Datenmodell mag auf den ersten Blick einfach und eingeschränkt erscheinen, es hat sich aber in der praktischen Anwendung gezeigt, dass das Datenmodell alle Strukturen abdeckt, die bei semistrukturierten Daten auftreten.
</p>

<h2>Das Metamorph-Datenmodell im Detail</h2>

<p>In den folgenden Abschnitten werden einige Detailaspekte des Metamorph-Datenmodells vorstellt. Ein besonderes Augenmerk liegt dabei auf Techniken, die es ermöglichen, auch spezielle Anwendungsfälle im Metamorph-Datenmodell elegant darstellen zu können.
</p>

<h3 id="entitätenDatensätze">Entitäten als Datensätze und Datensätze als Entitäten</h3>

<p>Es fällt auf, dass die Beschreibung der Funktion der Entitäten und des Datensatzes sehr ähnlich ist. In der Tat ist es so, dass sich ein Datensatz von einer Entität strukturell nur dadurch unterscheidet, dass er die äußere Hülle der Datenstruktur bildet. Es ist daher problemlos möglich, einen Datensatz in einen anderen als Entität einzubetten oder eine Entität aus einem Datensatz herauszuziehen und als eigenen Datensatz zu betrachten. Dabei sollte nur beachtet werden, dass sowohl Datensatz-ID als auch Entitätsname zwar beliebige Werte annehmen können, die ihnen zugeschriebene Bedeutung aber leicht unterschiedlich ist. Während die Datensatz-ID einen konkreten Datensatz bezeichnet und sich von Datensatz zu Datensatz unterscheidet, dient der Entitätsname der Identifikation einer Entität in der Datensatzstruktur und ist bei jedem Datensatz gleich. Aus diesem Grund ist es sinnvoll, beim Umwandeln eines Datensatzes in eine Entität nicht die Datensatz-ID als Entitätsname zu verwenden, sondern einen festen Namen. Andersherum sollte beim Herauslösen eines Datensatzes eine ID generiert werden, statt einfach den Entitätsnamen zu verwenden.
</p>

<p>Am Beispiel unseres Buchtitels können wir das Problem leicht nachvollziehen. Im folgenden Beispiel sind die Entitäten mit den Angaben zu den Autoren und dem Herausgeber aus dem Titeldatensatz herausgezogen und als gesonderte Personendatensätze dargestellt. Als Datensatz-IDs wurden einfach die Entitätsnamen verwendet:
</p>

<div class="RecordSet">
	<div class="Record">
		<span class="RecordId">Datensatz mit ID &ldquo;978-3-525-20764-2&rdquo;</span>
		<dl>
			<dt>title</dt><dd>Kinder- und Hausmärchen</dd>
			<dt>publicationYear</dt><dd>1986</dd>
			<dt>publisher</dt><dd>Vandenhoeck und Ruprecht</dd>
			<dt>location</dt><dd>Göttingen</dd>
			<dt>isbn</dt><dd>978-3-525-20764-2</dd>
		</dl>
	</div>
	<div class="Record">
		<span class="RecordId">Datensatz mit ID &ldquo;author&rdquo;</span>
		<dl>
			<dt>surname</dt><dd>Grimm</dd>
			<dt>forename</dt><dd>Jacob</dd>
			<dt class="Entity">affiliation</dt>
			<dd>
				<dl>
					<dt>institution</dt><dd>Friedrich-Wilhelms-Universität zu Berlin</dd>
					<dt>country</dt><dd>Preußen</dd>
				</dl>
			</dd>
		</dl>
	</div>
	<div class="Record">
		<span class="RecordId">Datensatz mit ID &ldquo;author&rdquo;</span>
		<dl>
			<dt>surname</dt><dd>Grimm</dd>
			<dt>forename</dt><dd>Wilhelm</dd>
			<dt>forename</dt><dd>Carl</dd>
			<dt class="Entity">affiliation</dt>
			<dd>
				<dl>
					<dt>institution</dt><dd>Universität Göttingen</dd>
					<dt>country</dt><dd>Königreich Hannover</dd>
				</dl>
			</dd>
		</dl>
	</div>
	<div class="Record">
		<span class="RecordId">Datensatz mit ID &ldquo;editor&rdquo;</span>
		<dl>
			<dt>surname</dt><dd>Rölleke</dd>
			<dt>forename</dt><dd>Heinz</dd>
		</dl>
	</div>
</div>

<p>Das Ergebnis zeigt, dass wir zwei Datensätze mit der ID &ldquo;author&rdquo; haben, sodass wir die Datensätze nicht mehr eindeutig identifizieren können. Ein weiterer Nachteil dieses Vorgehens ist, dass die Personen nun fest als Autoren oder Herausgeber benannt werden, obwohl dies eine Eigenschaft ist, die sie eigentlich nur im Zusammenhang mit einem Buch besitzen. Es ist ja durchaus möglich, dass etwa Jacob Grimm bei einem Buch Autor und bei einem anderen Herausgeber war.
</p>

<p>Um diese Probleme zu vermeiden, ist es sinnvoll, beim Herauslösen der Personendatensätze die Entitätsnamen durch <strong>eindeutige Datensatz-IDs</strong> zu ersetzen. Dies erlaubt es uns nämlich auch, in dem Titeldatensatz auf diese Datensätze zu verweisen und Jacob und Wilhelm Grimm so als Autoren und Heinz Rölleke als Herausgeber zu identifizieren.</p>

<div class="RecordSet">
	<div class="Record">
		<span class="RecordId">Datensatz mit ID &ldquo;978-3-525-20764-2&rdquo;</span>
		<dl>
			<dt>title</dt><dd>Kinder- und Hausmärchen</dd>
			<dt>authoredById</dt><dd>person-1</dd>
			<dt>authoredById</dt><dd>person-2</dd>
			<dt>editedById</dt><dd>person-3</dd>
			<dt>publicationYear</dt><dd>1986</dd>
			<dt>publisher</dt><dd>Vandenhoeck und Ruprecht</dd>
			<dt>location</dt><dd>Göttingen</dd>
			<dt>isbn</dt><dd>978-3-525-20764-2</dd>
		</dl>
	</div>
	<div class="Record">
		<span class="RecordId">Datensatz mit ID &ldquo;person-1&rdquo;</span>
		<dl>
			<dt>surname</dt><dd>Grimm</dd>
			<dt>forename</dt><dd>Jacob</dd>
			<dt class="Entity">affiliation</dt>
			<dd>
				<dl>
					<dt>institution</dt><dd>Friedrich-Wilhelms-Universität zu Berlin</dd>
					<dt>country</dt><dd>Preußen</dd>
				</dl>
			</dd>
		</dl>
	</div>
	<div class="Record">
		<span class="RecordId">Datensatz mit ID &ldquo;person-2&rdquo;</span>
		<dl>
			<dt>surname</dt><dd>Grimm</dd>
			<dt>forename</dt><dd>Wilhelm</dd>
			<dt>forename</dt><dd>Carl</dd>
			<dt class="Entity">affiliation</dt>
			<dd>
				<dl>
					<dt>institution</dt><dd>Universität Göttingen</dd>
					<dt>country</dt><dd>Königreich Hannover</dd>
				</dl>
			</dd>
		</dl>
	</div>
	<div class="Record">
		<span class="RecordId">Datensatz mit ID &ldquo;person-3&rdquo;</span>
		<dl>
			<dt>surname</dt><dd>Rölleke</dd>
			<dt>forename</dt><dd>Heinz</dd>
		</dl>
	</div>
</div>

<p>Als Datensatz-IDs der herausgelösten Datensätze werden im Beispiel nun eindeutige Nummern verwendet. Außerdem wurden die <var>author</var>- und <var>editor</var>-Entitäten im Titeldatensatz  durch Literale ersetzt, die als Datenwert die Datensatz-ID der vormals dort eingebundenen Entität haben. Um kenntlich zu machen, dass diese Literale keinen Autoren- bzw. Herausgebernamen enthalten, wurden ihre Namen zu <var>authoredById</var> und <var>editedById</var> geändert. Damit wird am Literalnamen erkennbar, dass die Literale nur Verweise enthalten. Gleichzeitig werden aber auch die Beziehungen zwischen dem Titeldatensatz und den Personendatensätzen beschrieben, ohne dass die Personen auf eine bestimmte Rolle festgelegt sind, wie im vorherigen Beispiel noch der Fall war. Trotz der besonderen Namen mit dem Anhängsel <var>Id</var> unterscheiden sich die Literale aus Sicht des Metamorph-Datenmodells nicht von anderen Literalen. Das Datenmodell kennt keine besonderen Strukturelemente für Verknüpfungen zwischen Datensätzen. Es liegt in den Händen des Anwenders, die Datenwerte der neu eingefügten Literale als Verweise auf andere Datensätze zu deuten.
</p>

<h3 id="nameDetails">Vokabulare und Ontologien für Literale und Entitäten</h3>

<p>Bei der Einführung der Literale wurde bereits kurz erwähnt, dass die Literalnamen völlig beliebig sein können und dass das Metamorph-Datenmodell keinerlei Vorgaben macht, wie Namen für Literale und Entitäten zu gestalten sind. Dies ist eine wichtige Eigenschaft des Datenmodells: Es definiert nur die verfügbaren Strukturelemente (Literale und Entitäten), aber nicht, wie diese kombiniert und benannt werden müssen, um Daten aus einem bestimmten Anwendungsbereich (bspw. bibliothekarische Titelaufnahmen) zu beschreiben. Dies kann je Art der Daten völlig unterschiedlich sein und ermöglicht es, Metamorph für die Verarbeitung von Daten aus verschiedensten Anwendungsbereichen einzusetzen. Voraussetzung ist nur, dass sich die Daten in einer hierarchischen Datenstruktur mit Schlüssel-Wert-Paaren abbilden lassen. Das ist dieselbe Idee, die auch XML zugrunde liegt: Es wird eine allgemeine Struktur vorgegeben, die konkrete Ausprägung bleibt aber dem Anwender überlassen, sodass eine Nutzung in unterschiedlichen Anwendungsbereichen möglich ist.
</p>

<p>Je nach Anwendungsfall können Literal- und Entitätsnamen unterschiedlich gewählt werden. In dem Beispiel im vorherigen Abschnitt folgen die Namen bspw. keinem bestimmtem bibliothekarischen Format, sondern wurden einfach so gewählt, dass ihre Bedeutung sofort verständlich wird. Wenn allerdings Daten verarbeitet werden sollen, die bereits in einem bestimmten domänenspezifischen Format vorliegen, ist es meist sinnvoll, die Benennung und Strukturvorgaben dieses Formats zu übernehmen. So bleibt die ursprüngliche Bedeutung der Daten erhalten und sie können trotzdem mit Metamorph verarbeitet werden.
</p>

<p>Die Gesamtheit der domänenspezifischen Strukturen und Benennungen, die in einem konkreten Anwendungsfall verwendet werden, bezeichnen wir in Anlehnung an die Semantic Web verwendete Terminologie als <dfn>Vokabular</dfn> bzw. <dfn>Ontologie</dfn> (im XML-Jargon würde man hingegen von einem <dfn>Schema</dfn> sprechen). Vokabulare umfassen dabei nur die in einem Anwendungsfall erlaubten Literal- und Entitätsnamen, während Ontologien auch die Festlegungen zur Strukturierung beinhalten. Die folgende Tabelle listet in der ersten Spalte das Vokabular auf, das wir in unserem obigen Beispiel verwendet haben, und in der zweiten Spalte die dazugehörige Ontologiedefinition.</p>

<table class="NotHyphenated">
	<thead>
		<tr>
			<th>Vokabular</th><th>Ontologie</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><i>Datensatz</i></td>
			<td>Enthält eine oder mehrere author-Entitäten unter Berücksichtigung ihrer Reihenfolge, eine editor-Entität und je ein title-, publisherYear-, publisher-, location- und isdn-Literal</td>
		</tr>
		<tr>
			<td>author</td>
			<td>Entität, enthält ein surname-Literal und ein oder mehrere forename-Literale</td>
		</tr>
		<tr>
			<td>editor</td>
			<td>Entität, enthält ein surname-Literal und ein oder mehrere forename-Literale</td>
		</tr>
		<tr>
			<td>title</td><td>Literal</td>
		</tr>
		<tr>
			<td>publisherYear</td><td>Literal</td>
		</tr>
		<tr>
			<td>publisher</td><td>Literal</td>
		</tr>
		<tr>
			<td>location</td><td>Literal</td>
		</tr>
		<tr>
			<td>isbn</td><td>Literal</td>
		</tr>
		<tr>
			<td>surname</td>
			<td>Literal</td>
		</tr>
		<tr>
			<td>forename</td>
			<td>Literal</td>
		</tr>
	</tbody>
</table>

<p>Im Gegensatz zu RDF und XML gibt es im Metamorph-Datenmodell keinen Standard, um eine <strong>Ontologie formal zu definieren</strong>. In der Tabelle sind die erlaubten Datenstrukturen deshalb in textueller Form beschrieben. Grundsätzlich bietet die Möglichkeit, eine Datenstruktur formal beschreiben zu können, einige Vorteile bei der Datenverarbeitung. So bildet eine formale Ontologie eine unmissverständliche Dokumentation der in einer Anwendung zulässigen Datenstrukturen. Auch kann man mit ihr die Korrektheit von konkreten Ein- und Ausgabedaten überprüfen und garantieren. Wir haben uns trotz dieser Vorteile dagegen entschieden, dem Metamorph-Datenmodell einen Standard für die formale Definition von Ontologien zur Seite zu stellen.
</p>

<p>Das Metamorph-Datenmodell wird in erster Linie verwendet, um Daten aus anderen existierenden Formaten darzustellen. Daher liegen oftmals bereits formale Ontologiedefinitionen zu diesen Ursprungsformaten vor, die zur Dokumentation herangezogen werden können. Eine spezielle Ontologiebeschreibung für die Repräsentation im Metamorph-Datenmodell böte keinen dokumentarischen Mehrwert. Weiterhin steht dem Wunsch, die Korrektheit von Ein- und Ausgabedaten validieren zu können, die hohe Variabilität semistrukturierter Daten entgegen, deren Struktur häufig nicht allgemein definiert ist, sondern von den konkret vorliegenden Daten abhängt. In der Praxis ist es für viele semistrukturierte Daten verhältnismäßig schwierig und aufwändig, Ontologien zu erstellen. Angesichts dessen wurde beim Entwurf von Metamorph entschieden, das System für die Verarbeitung von <strong>schema-freien Daten</strong>  &ndash; d.&thinsp;h. Daten, deren Struktur nicht in einer Ontologie definiert ist &ndash; auszulegen, und es robust gegenüber fehlerhaften oder unerwarteten Datenstrukturen zu gestalten.
</p>

<h4>Strukturierte Literal- und Entitätsnamen</h4>

<p>Bei schema-freien Daten gibt es keine Möglichkeit Zusatzinformationen zu einzelnen Literalen in einer Ontologie zu hinterlegen. Solche zusätzlichen Informationen sind aber oft für die Arbeit mit den Daten hilfreich, und es ist deshalb wünschenswert sie in die Datenmodellierung zu integrieren. Derartige Zusatzinformationen können bspw. Angaben zur Sprache oder zum Datentyp eines Literalwerts sein oder ein Hinweis darauf, dass der Datenwert eines Literals ein Verweis auf einen anderen Datensatz ist.
</p>

<p>Eine Möglichkeit, solche Informationen im Metamorph-Datenmodell darzustellen, ist die <strong>Ersetzung des Literals durch eine Entität</strong>. In dieser gibt es dann ein Literal, das den Wert des ursprünglichen Literals enthält und zusätzlich weitere Literale, in denen die zusätzlichen Informationen über den Datenwert abgelegt sind. Nehmen wir an, wir haben in einem Datensatz folgendes Literal, das einen englischsprachigen Buchtitel enthält:
</p>

<div class="RecordSnippet">
	<dl>
		<dt>title</dt><dd>Grimms' Fairy Tales</dd>
	</dl>
</div>

<p>Um dieses Wissen, dass der Titel in diesem Literal in englischer Sprache vorliegt, festzuhalten, können wir das Literal in eine Entität mit Zusatzinformationen umbauen:</p>

<div class="RecordSnippet">
	<dl>
		<dt class="Entity">title</dt>
		<dd>
			<dl>
				<dt>value</dt><dd>Grimms' Fairy Tales</dd>
				<dt>language</dt><dd>en</dd>
			</dl>
		</dd>
	</dl>
</div>

<p>Das <var>value</var>-Literal in der <var>title</var>-Entität entspricht hier dem ursprünglichen Wert des <var>title</var>-Literals, und die Zusatzinformation zur Sprache ist als zusätzliches Literal in der Entität enthalten. Die Entität selbst wird dann anstelle des ursprünglichen <var>title</var>-Literals verwendet.
</p>

<p>Diese Lösung erfüllt ihren Zweck, hat allerdings den Nachteil, die Struktur des Datensatzes deutlich zu verändern. Dies ist nicht immer gewünscht, insbesondere wenn die Zusatzinformationen eigentlich recht kompakt sind, wie es etwa bei Sprachangaben oder Verknüpfungshinweisen der Fall ist. Eine Möglichkeit, zu einer kompakteren Darstellung zu kommen, ist die <strong>Verwendung strukturierter Literal- und Entitätsnamen</strong>. So könnten wir im obigen Beispiel einfach festlegen, dass an einen Literalnamen ein @-Zeichen<a class="Footnote" href="#atCharForLanguage" id="atCharForLanguageRef"></a> gefolgt von einem Sprachcode angehängt werden kann, um die Sprache des Literalwerts anzugeben. Unser <var>title</var>-Literal sähe dann wie folgt aus:
</p>

<section class="Footnote">
	<p><a href="#atCharForLanguageRef" id="atCharForLanguage"></a>Die Verwendung des @-Zeichens zur Angabe der Sprache wurde vom RDF-Turtle-Format übernommen. Im Prinzip hätten wir auch jedes beliebige andere Zeichen verwenden können. Der Rückgriff auf bereits etablierte Konventionen vereinfacht aber die Verständlichkeit der Daten.
	</p>
</section>

<div class="RecordSnippet">
	<dl>
		<dt>title@en</dt><dd>Grimms' Fairy Tales</dd>
	</dl>
</div>

<p>Andere Varianten von strukturierten Namen, die in Metafacture-basierten Anwendungen bereits eingesetzt wurden, sind das Voranstellen eines *-Zeichens oder eines ~-Zeichens, um Literale zu markieren, die eine URL als Verweis enthalten, oder Literale, die als XML-Attribute zu behandeln sind.</p>

<p>Der Nutzen strukturierter Namen ist natürlich nicht nur auf Literale beschränkt, sondern kann auch bei Entitätsnamen angewendet werden. Ein Beispiel ist die Verwendung von [] als Anhängsel an Entitätsnamen zur Kennzeichnung, dass die Literale in der Entität als eine Auflistung zu verstehen sind:
</p>

<div class="RecordSnippet">
	<dl>
		<dt class="Entity">authors[]</dt>
		<dd>
			<dl>
				<dt>author</dt><dd>Jacob Grimm</dd>
				<dt>author</dt><dd>Wilhelm Carl Grimm</dd>
			</dl>
		</dd>
	</dl>
</div>

<p>Die einzeln <var>author</var>-Literale für die Autoren eines Buches wurden in dem Beispiel nicht einfach direkt in einen Datensatz geschrieben, sondern in einer Entität mit dem Namen <var>authors[]</var> zusammengefassst. Dies erscheint auf den ersten Blick einfach eine Doppelung zu sein, die keinen semantischen Mehrwert bietet. Der Vorteil dieser Darstellungsweise ist indes, dass die Tatsache, dass es sich bei den <var>author</var>-Literalen um eine Liste handelt, nicht mehr nur implizit durch Wiederholung der Literale im Datensatz ausgedrückt ist, sondern explizit durch das Zusammenfassen in einer Entität, deren Name auf ihre Funktion als Liste hinweist. Dies kann die Arbeit mit derart strukturierten Daten sehr vereinfachen, da sofort ersichtlich ist, wenn Teile eines Datensatzes als Liste behandelt werden sollen.
</p>

<p>Die Integration von Zusatzinformationen in die Literal- und Entitätsnamen ist eine einfache und vielseitige Technik. Bei ihrer Verwendung sollte allerdings beachtet werden, dass diese Zusatzinformationen leicht übersehen werden können und dass die Bedeutung verschiedener Angaben in den Namen nicht immer selbsterklärend ist. Außerdem kann es notwendig werden, im Zuge der Datenverarbeitung die Zusatzinformationen wieder aufwändig aus den Namen herauszutrennen. Bei komplexeren Zusatzinformationen, die nicht nur aus einem einfachen Wert bestehen, sollte man die oben beschriebene Entitäten-Methode der strukturierten Benennung vorziehen. Für kompakte Informationen wie die Kennzeichung von Verweisen oder Hinweise auf Sprachangaben, ist sie jedoch oft die beste Lösung.
</p>

<h3>Datentypen</h3>

<p>Die Verwendung strukturierter Literalnamen kann auch hilfreich sein, um damit umzugehen, dass das Metamorph-Datenmodell anders als bspw. XML und RDF nicht zwischen verschiedenen Typen von Datenwerten unterscheidet. So ist es nicht möglich, festzulegen, dass ein Literal nur eine bestimmte Art von Werten &ndash; etwa nur Datumsangaben oder Zahlen &ndash; enthält. Alle Namen und Datenwerte im Metamorph-Datenmodell sind immer Zeichenfolgen. Der Hintergrund für diese Entscheidung ist, dass im bibliothekarischen Bereich &ndash; in dem Metafacture seine Wurzeln hat &ndash; meist alle Informationen als Text erfasst werden, denn Zahlen, Datumsangaben und andere Datenwerte lassen sich im Normalfall leicht als Zeichenfolgen darstellen. Dies hat den Vorteil, dass auch von der Norm abweichende Angaben für einzelne Werte problemlos erfasst werden können. Würde bspw. das Literal <var>publicationYear</var> den Datentyp Datumsangabe besitzen, könnten Angaben wie &ldquo;ca. 1560&rdquo; oder &ldquo;anno 1066&rdquo; nicht mehr verarbeitet werden. Da derartige Sonderfälle in semistrukturierten Daten häufig vorkommen, bietet sich die Verwendung von <strong>Zeichenfolgen als allgemeiner Datentyp</strong> im Metamorph-Datenmodell an.
</p>

<p>Um dennoch Informationen zum gewünschten Datentyp eines Literalwerts festhalten zu können, bieten sich strukturierte Literal- und Entitätsnamen an. Wenn wir z.&thinsp;B. ausdrücken wollen, dass im Literal <var>publicationYear</var> nur Datumsangaben stehen sollen, könnten wir den Namen einfach mit einer Angabe wie <var>publicationYear^^IsoDate</var><a class="Footnote" href="#caretForDatatype" id="caretForDatatypeRef"></a> erweitern. Damit würden wir darauf hinweisen, dass das Erscheinungsjahr eine ISO-konforme Datumsangabe sein sollte. Für die Angabe des Datenformats wurde hier ein selbstdefinierter Datentypname verwendet. Um die genutzten Datentypen eindeutig zu definieren, ist es gleichwohl meist hilfreich, auf bereits existierende Datentypdefinitionen aus anderen Standards zurückzugreifen. Ein Standard, der sich dafür anbietet, ist XML-Schema. Dieser definiert Datentypen für Datenarten, die in semistrukturierten Daten häufig anzutreffen sind. XML-Schema-Datentypen werden darüberhinaus oft auch für Datentypauszeichnungen in RDF verwendet. Im Metamorph-Datenmodell könnte ein Literalname für ein Literal mit Datumsangaben unter Verwendung von XML-Schema-Datentypen in der Form <var>publicationYear^^xs:date</var> beschrieben werden, wobei <var>xs:</var> als Hinweis auf XML-Schema<a class="Footnote" href="#xmlSchemaDatatypes" id="xmlSchemaDatatypesRef"></a> dient. Auch bei der Verwendung etablierter Datentypen muss immer bedacht werden, dass dies nur Hinweise an den Benutzer sind; Metamorph wertet diese Angaben in keiner Weise aus. Es ist aber natürlich möglich, Erweiterungen für Metafacture zu entwickeln, die diese Informationen in den Literalnamen bspw. für Überprüfungen oder Korrekturen verwenden. <!-- TODO: Verweis auf Kapitel zu Entwicklung von Modulen -->
</p>

<section class="Footnote">
	<p><a href="#caretForDatatypeRef" id="caretForDatatype"></a>Die Verwendung von ^^ zur Kennzeichung des Datentyps ist &ndash; wie schon das @-Zeichen für Sprachangaben &ndash; ebenfalls vom RDF-Turtle-Format übernommen.
	</p>
</section>

<section class="Footnote">
	<p><a href="#xmlSchemaDatatypesRef" id="xmlSchemaDatatypes"></a>Diese Schreibweise entspricht dem Format der Angabe von Namensräumen in XML und RDF. Auch wenn das Metamorph-Datenmodell keine Namensräume kennt, hilft diese Schreibweise deutlich zu machen, dass es sich um Datentypen aus XML-Schema handelt.
	</p>
</section>

<h2>Datenformate</h2>

<p>Die oben beschriebene Trennung von Strukturelementen und Vokabular bzw. Ontologie ist eine Voraussetzung, um das Metamorph-Datenmodell in verschiedenen Anwendungsbereichen nutzen zu können. Die zweite Voraussetzung ist die Fähigkeit, <strong>verschiedene Datenformate für die Ein- und Ausgabe</strong> verwenden zu können. Aus diesem Grund definiert das Metamorph-Datenmodell nur die logische Datenstruktur und macht keine Festlegungen zur konkreten Repräsentation von Daten bei der Anzeige oder bei der Speicherung. Die Beispiele in diesem Kapitel sind deshalb auch grafisch und nicht als formatierter Text dargestellt.
</p>

<!-- Ab hier überarbeiten!

Es fehlt hier der Aspekt, dass Daten aus beliebigen Formaten eingelesen werden können. Das kommt noch nicht richtig rüber.

Die Tatsache, dass Formate sehr unterschiedlich sein können muss noch detaillierter ausgeführt werden.

-->

<p>Das Metamorph-Datenmodell unterscheidet sich in diesem Aspekt deutlich von XML. Durch die Verwendung verschiedener Vokabulare bzw. Schemata kann XML zwar an unterschiedliche Anwendungsdomänen angepasst werden, das zu verwendende Datenformat (XML) ist aber fest vorgegeben. RDF geht an dieser Stelle weiter und definiert in erster Linie ein Datenmodell und unabhängig davon mehrere Serialisierungsformate. Die Serialisierungen sind aber nichtsdestotrotz ein fester Bestandteil von RDF. Dies hängt natürlich auch mit der Verwendung von RDF als universelles Datenaustauschformat im <i>Semantic Web</i> zusammen. Dessen ungeachtet haben RDF und das Metamorph-Datenmodell ihre Fokussierung auf das Datenmodell statt auf ein Serialisierungsformat gemeinsam.
</p>

<p>Bei den meisten Datenformaten muss berücksichtigt werden, dass sie keine eins-zu-eins Abbildung der Strukturelemente des Metamorph-Datenmodells erlauben. Oft umfassen einzelne Datenformate nicht den vollen Umfang des Datenmodells, sondern beschränken einige Eigenschaften wie bspw. die erlaubte Verschachtelungstiefe von Entitäten, sodass nicht alle Datenstrukturen in dem jeweiligen Format abgebildet werden können. Teilweise gibt es auch mehrere Varianten, wie ein Strukturelement eines Datenformats im Metamorph-Datenmodell abgebildet werden kann. Dies betrifft z.&thinsp;B. oft die Darstellung von Listen.
</p>

<p>Um das Metamorph-Datenmodell praktisch einsetzen zu können, muss es aber natürlich möglich sein, Daten darstellen und vor allem ein- und auslesen (also serialisieren und deserialisieren) zu können.  Um mit unterschiedlichen Datenformaten arbeiten zu können, definiert Metamorph nur eine Schnittstelle für das Empfangen und Senden von Datensätzen, die gemäß des Metamorph-Datenmodells strukturiert sind. Die Konstruktion dieser Datensätze aus konkreten Datenformaten ist in speziellen Dekodier- und Enkodiermodule umgesetzt, die unabhängig von Metamorph sind.
</p>

<h3>Das Formeta-Format</h3>

<p>Da es in der Praxis häufig hilfreich ist, Daten direkt im Metamorph-Datenmodell anzeigen oder ablegen zu können, ohne sich Gedanken über die Fähigkeiten eines bestimmten Formats machen zu müssen, haben wir in Metafacture ein eigenes Datenformat namens <dfn>Formeta</dfn> integriert. Dieses Datenformat wurde passend zum Metamorph-Datenmodell entworfen, sodass es alle in dem Datenmodell möglichen Datenstrukturen direkt abbilden kann. Dabei muss aber noch einmal betont werden, dass Formeta nur <em>ein</em> mögliches Datenformat ist, um Daten im Metamorph-Datenmodell zu serialisieren. Im täglichen Gebrauch wird man weitaus häufiger etablierte Datenformate für die Ein- und Ausgabe verwenden und Formeta nur für die Anzeige oder Ablage von Zwischenergebnissen gebrauchen.
</p>

<p>Das Formeta-Format ist einfach aufgebaut, hat aber eine flexible Syntax, sodass wir Daten sowohl sehr kompakt als auch übersichtlich formatiert ausgeben können. Beim Entwurf der Syntax wurde außerdem darauf geachtet, dass auch eine manuelle Eingabe von Daten recht einfach ist.
</p>

<p>Das folgende Syntaxdiagramm zeigt die <strong>Grundstruktur des Formeta-Formats</strong>:
</p>

<figure>
	<img src="formeta-grundstruktur.svg" />
	<figcaption>Grundstruktur des Formeta-Formats</figcaption>
</figure>

<p>Eine Serialisierung im Formeta-Format ist eine Folge von Literalen und Gruppen (den Spezialfall des Leernamens betrachten wir später). Die Literale entsprechen denen des Metamorph-Datenmodells, die Gruppen dienen sowohl der Serialisierung von Datensätzen als auch von Entitäten. Durch die Verwendung derselben Syntax für Datensätze und Entitäten ist es sehr einfach,  die oben beschriebene Technik anzuwenden, Datensätze als Entitäten in andere Datensätze einzubetten. Durch die identische Darstellung kann die Anwenderin flexibel entscheiden, ob eine Gruppe als Datensatz oder Entität zu verstehen ist.
</p>

<p>Wie im Diagramm erkennbar ist, setzt Formeta nicht zwingend voraus, dass eine Serialisierung mit einer Gruppe &ndash; d.&thinsp;h. der serialisierten Form eines Datensatzes &ndash; beginnen muss. Es ist auch möglich, einzelne Literale und Entitäten direkt ohne einen umschließende Gruppe zu serialisieren. Auf diese Weise können auch Ausschnitte aus einem umfangreichen Datensatz dargestellt oder abgelegt werden. Wie auch bei der Entscheidung, ob eine Gruppe als Datensatz oder Entität zu sehen ist, liegt es in den Händen des Anwenders zu entscheiden, ob im konkreten Anwendungsfall vollständige Datensätze oder nur Ausschnitte verarbeitet werden. Die Syntax des Formeta-Formats erlaubt beides.
</p>

<p>Neben Literalen und Gruppen kennt Formeta noch <strong>Leernamen</strong>. Diese haben im Gegensatz zu den anderen beiden Elementen keine inhaltliche Bedeutung, sondern ermöglichen nur eine flexiblere Syntax. Ein Leername ist eine Zeichenfolge, die entweder aus keinerlei Zeichen besteht oder nur aus Leerraum. Außerdem werden zwei direkt aufeinanderfolgende Anführungszeichen mit umgebendem Leerraum als Leername behandelt:
</p>

<figure>
	<img src="formeta-leername.svg" />
	<figcaption>Struktur der Leernamen im Formeta-Format</figcaption>
</figure>

<p>Ein Leername kann anstelle eines Literals oder einer Gruppe stehen, sodass direkt das Folgeelement angeschlossen werden kann. Da Leernamen keine semantische Bedeutung haben, ermöglicht es diese Konstruktion, nach Belieben Leerraum zwischen Literalen und Gruppen einzufügen.
</p>

<p>Als <strong>Leerraum</strong> gelten Leerzeichen, Zeilenumbrüche und Tabulatoren:
</p>

<figure>
	<img src="formeta-leerraum.svg">
	<figcaption>Die erlaubten Leerraum-Zeichen</figcaption>
</figure>

<p>Literale und Leernamen müssen mit einem Komma abgeschlossen werden, es sei den, es handelt sich um das letzte Element der Serialisierung, dann ist ein Komma optional (in Fall eines abschließenden Kommas folgt dann aus Sicht der Syntax einfach noch ein Leername nach diesem letzten Komma). Auf Gruppen kann direkt ein Literal, Leername oder eine weitere Gruppe folgen, ohne dass ein trennendes Komma nötig ist. Da auf eine Gruppe direkt ein Leername folgen darf, der mit einem Komma abgeschlossen wird, ist es auch möglich Gruppen mit Kommata zu trennen ohne die Semantik zu verändern. Die Leernamen erlauben es auch, mehrere direkt aufeinander folgende Kommata zu setzen, ohne dass dies semantisch von Bedeutung ist. Das folgende Beispiel illustriert, wie zwei Datensätze durch die flexible Kommasetzung auf unterschiedliche Weise mit Formeta serialisiert werden können. Trotz der optischen Unterschiede ist die Datenstruktur in beiden Fällen vollkommen identisch.
</p>

<figure>
	<pre class="Example">
person-1 {
	Name: Grimm,
	Vorname: Wilhelm,
	Vorname: Carl
}
person-2 {
	Name: Grimm,
	Vorname: Jacob
}
<hr><!-- Umbruch ignorieren
-->person-1 {
	Name: Grimm,,
	Vorname:Wilhelm,,
	Vorname: Carl,,
},
person-2 {
	Name: Grimm,
	Vorname: Jacob,
},<!-- Umbruch ignorieren
--></pre>
	<figcaption>Bei oberen Formeta-Serialisierung wurden nur die minimal notwendigen Kommata gesetzt. Bei der Unteren dagegen wurden Kommata großzügig auch an Stellen verwendet, wo sie nicht zwingend nötig wären</figcaption>
</figure>

<p><strong>Literale und Gruppen</strong> bestehen jeweils aus einem Namen gefolgt von einem Doppelpunkt oder einer öffnenden geschweiften Klammer. Anhand dieser beiden Zeichen kann ein Formeta-Parser unterscheiden, ob es sich um einen Literalnamen (Doppelpunkt) oder Gruppennamen (geschweifte Klammer) handelt. Im Falle des Literals folgt dann einfach der Literalwert. Bei Gruppen können innerhalb der Gruppe wieder alle Formeta-Elemente auftauchen. Damit können Daten in Formeta rekursiv &ndash; d.&thinsp;h. beliebig verschachtelt &ndash; abgelegt werden. Die Gruppe wird mit einer schließenden geschweiften Klammer abgeschlossen.
</p>

<figure>
	<img src="formeta-literal.svg">
	<img src="formeta-gruppe.svg">
	<figcaption>Aufbau der beiden bedeutungstragenden Grundelemente des Formeta-Formats</figcaption>
</figure>

<p><strong>Namen und Werte</strong> können auf zwei Arten im Formeta-Format dargestellt werden. Entweder als Text in einfachen Anführungszeichen (<var>Text-in-AF</var>) oder als Text ohne Anführungszeichen. Die Verwendung von Anführungszeichen reduziert die Anzahl der Zeichen, die maskiert werden müssen. Vor und nach einem Namen oder Wert darf beliebiger Leerraum vorhanden sein. Dadurch kann die Formeta-Serialisierung durch das Einfügen von Einrückungen und Zeilenumbrüchen übersichtlich gegliedert werden. Das Diagramm zeigt auch, dass leere Namen und Werte zulässig sind:
</p>

<figure>
	<img src="formeta-name-wert.svg">
	<figcaption>Darstellung von Namen und Werten im Formeta-Format</figcaption>
</figure>

<p>Innerhalb von <strong>Text in Anführungszeichen</strong> können beliebige Zeichenfolgen inklusive Leerraumzeichen und Sonderzeichen angegeben werden. Einzig das einfache Anführungszeichen und der Backslash haben eine Sonderfunktion und können nicht einfach im Text verwendet werden. Das einfache Anführungszeichen beendet den Text und der Backslash maskiert das nachfolgende Zeichen. Dies erlaubt es auch Anführungszeichen und Backslashs im Text einzugeben, indem ihnen ein Backslash vorangestellt werden, sodass sie ihre Spezialbedeutung verlieren.
</p>

<figure>
	<img src="formeta-text-in-af.svg">
	<figcaption>Text in Anführungszeichen</figcaption>
</figure>

Neben den beiden zwingend zu maskierenden Zeichen ist es möglich, noch weitere Zeichen mit einem Backslash in einer <strong>Escape-Sequenz</strong> zu maskieren:

<figure>
	<img src="formeta-esc-sequenz.svg">
	<figcaption>Maskierung mit einem Backslash und maskierbare Zeichen.</figcaption>
</figure>

<p>Die sechs Interpunktionszeichen können mit einem Backslash maskiert werden, um sie ihrer Sonderfunktion, die sie ansonsten im Formeta-Format haben, zu berauben. Die Maskierung von Leerraumzeichen ermöglicht es, diese am Beginn oder Ende eines nicht in Anführungszeichen stehenden Textes zu nutzen. Während die vorgenannten Zeichen ihre Sonderfunktion durch die Maskierung verlieren, ist es bei den Zeichen <code>r</code> und <code>n</code> gerade umgekehrt. Die Maskierung dieser beiden Zeichen erzeugt einer Sonderbehandlung: Mit <code>\n</code> können Zeilenumbrüche und mit <code>\r</code> Wagenrückläufe einzufügt werden, ohne einen sichtbaren Zeilenumbruch eingeben zu müssen, der ggf. die visuelle Struktur der Serialisierung beeinträchtigen würde.
</p>

<p>Das letzte Element der Formeta-Syntax ist einfacher <strong>Text ohne Anführungszeichen</strong>. Dieser bietet sich für Namen und Werte an, die keine oder nur wenige Sonderzeichen enthalten, die maskiert werden müssen. Da Leerraum vor und nach Texten ignoriert wird, muss ein Text ohne Anführungszeichen mit einem Nichtleerraumzeichen beginnen und enden. Um trotzdem einen Text mit einem der vier Leerraumzeichen beginnen oder enden lassen zu können, können diese Zeichen maskiert werden. Leerraum innerhalb des Texts ist unproblematisch, solange dahinter ein weiteres Nichtleerraumzeichen oder ein maskiertes Leerraumzeichen folgt. Bei Text ohne Anführungszeichen müssen im Gegensatz zu Text in Anführungszeichen die Zeichen Doppelpunkt, Komma und öffnende und schließende geschweifte Klammer ebenfalls maskiert werden, damit ein Formeta-Parser erkennen kann, dass sie Teil des Textes sind und nicht das Ende des Namens oder Werts markieren.
</p>

<figure>
	<img src="formeta-text.svg">
	<figcaption>Text ohne Anführungszeichen</figcaption>
</figure>

<h4>Formeta im praktischen Beispiel</h4>

<p>Zum Abschluss der Vorstellung von Formeta zeigt dieser Abschnitt einige Beispiele für die Beschreibung von Datensätzen im Formeta-Format, um einen Eindruck vom Aussehen der Serialisierung zu vermitteln. Als Datenbasis dienen die Beispieldatensätze aus diesem Kapitel. Die einzelnen Datensätze sind jeder mit einer anderen Schreibweise des Formeta-Formats dargestellt, um die verschiedenen Möglichkeiten zu illustrieren.
</p>

<p>Das erste Beispiel zeigt den Datensatz des Beispielbuchtitels aus diesem Kapitel in einer Formeta-Serialisierung, bei der alle Namen und Werte ohne Anführungszeichen geschrieben wurden. Der Doppelpunkt im Wert des Literals <var>publisher</var> wurde maskiert, um zu verhindern, dass er als Trennzeichen zwischen Literalnamen und Literalwert behandelt wird. Der Verzicht auf Anführungszeichen erlaubt eine zügige manuelle Eingabe und ergibt sehr übersichtliche Datensätze solange nicht zu viele Zeichen maskiert werden müssen. Zur zusätzlichen Verbesserung der Lesbarkeit wurden die Gruppeninhalte übersichtlich eingerückt.
</p>

<pre class="Example">
978-3-525-20764-2 {
	title: Kinder- und Hausmärchen,
	authoredById: person-1,
	authoredById: person-2,
	editedById: person-3,
	publicationYear: 1986,
	publisher: Vandenhoeck und Ruprecht\: Göttingen,
	isbn: 978-3-525-20764-2
}<!-- Umbruch ignorieren
--></pre>

<p>Im Gegensatz zum ersten Beispiel wurden im Folgenden alle Namen und Werte in Anführungszeichen gesetzt, sodass der Doppelpunkt im Wert des Literals <var>institution</var> nicht maskiert werden muss. Zusätzlich wurde eine andere Schreibweise für den Umbruch und die Einrückung verwendet.
</p>

<pre class="Example">
'person-1'
	{
	'surname':
			'Grimm',
	'forename':
			'Jacob',
	'birthdate':
			'1786-01-04',
	'affiliation'
		{
		'institution':
				'Friedrich-Wilhelms-Universität: Berlin',
		'country':
				'Preußen'
		}
	}<!-- Umbruch ignorieren
--></pre>

<p>Die Serialisierung des folgenden Datensatz verwendet im Kontrast zum obigen Datensatz sehr viel weniger Leerraum zur optischen Gliederung. Das mehrfach verwendete Literal <var>forename</var> wird sogar komplett in einer Zeile angegeben. Weiterhin enden auch die letzten Literale und Entitäten einer Gruppe mit einem Komma. Durch diese Schreibweise können bei häufigen manuellen Veränderungen an Datensätzen Fehler durch fehlende Kommata vermieden werden, wenn neue Literale oder Entitäten am Ende einer Gruppe eingefügt werden. Als letzte Besonderheit wurden bei der Serialisierung sowohl Texte in Anführungszeichen als auch Texte ohne Anführungszeichen verwendet. Letztere wurden für alle Namen verwendet, Erstere für alle Werte. Diese Kombination ist häufig sinnvoll, da die Literal- und Entitätsnamen oftmals einzelne Worte sind, die keine Sonderzeichen enthalten. Der Verzicht auf Anführungszeichen kann dann zur Lesbarkeit beitragen.
</p>

<pre class="Example">
person-2 {
	surname: 'Grimm',
	forename: 'Wilhelm', forename: 'Carl',
	affiliation {
		institution: 'Universität Göttingen',
		country: 'Königreich Hannover',
	},
}<!-- Umbruch ignorieren
--></pre>

<p>Während die vorangegangenen Datensätzen eine hohe Lesbarkeit und teilweise auch eine einfache Veränderbarkeit der Daten im Vordergrund stand, zeigt das abschließende Beispiel, dass mit Formeta auch sehr kompakte Formatierungen möglich sind:
</p>

<pre class="Example">
person-3{surname:Rölleke,forename:Heinz}<!-- Umbruch ignorieren
--></pre>

<p>Hier wurde auf alle unnötigen Leerräume, Kommata und Anführungszeichen verzichtet, um eine möglichst kompakte Darstellung zu erreichen. Diese ist für Menschen nur schwer lesbar, eignet sich aber gut für Daten, die nur vom Rechner gelesen und geschrieben werden.
</p>


<h3>Darstellung verschiedener Formate im Metamorph-Datenmodell</h3>

<p>Im Folgenden zeige ich wie verschiedene bekannte Datenformate im Metamorph-Datenmodell abgebildet werden können. Wir beginnen mit einem einfachen Datenformat aus dem Bibliotheksbereich und beschäftigen und anschließend mit XML, JSON und RDF. Diese Formate sind besonders interessant, da sie ebenfalls zur Erfassung beliebiger semistrukturierter Daten entwickelt wurden. Ihre Datenmodelle sind allerdings alle leicht unterschiedlich und unterscheiden sich auch vom Metamorph-Datenmodell. Wir werden aber sehen, dass es dennoch möglich ist, beliebig strukturierte Daten aus diesen Formate im Metamorph-Datenmodell zu modellieren. Dies zeit, dass sich jegliche in JSON, XML und RDF vorliegenden Daten mit Metamorph verarbeiten lassen.
</p>

<h4>Darstellung von PICA+ im Metamorph-Datenmodell</h4>

<p>Einer der ersten Anwendungsfälle für Metamorph war die Konversion von bibliothekarischen Daten, die im PICA+ Format vorlagen. Dieses Datenformat ist recht einfach strukturiert. Es gibt Datensätze, die jeweils bspw. einen Buchtitel oder eine Zeitschrift beschreiben. Ein Datensatz setzt sich aus sogenannten Feldern zusammen, die Angaben zu bestimmten Aspekten des beschriebenen Objekts enthalten. Da die Angaben oftmals noch eine feinere Untergliederung aufweisen, bestehen die Felder aus Unterfeldern. Felder und Unterfelder können wiederholbar sein. Bei gleichnamigen Feldern garantiert PICA+ keine bestimmte Reihenfolge dieser Felder. Wenn dies notwendig ist, kann der Feldname um eine sogenannte <dfn>Occurrence</dfn> ergänzt werden. Dabei handelt es sich um einen Index, der an den Feldnamen angehängt wird und die Position des Feldes beschreibt.
</p>

<p>Das folgende Beispiel zeigt einen Auschnitt aus einem Datensatz im PICA+ Format. Die ersten vier Zeichen in jeder Zeile bezeichnen den Feldnamen, eine ggf. vorhandene <i>Occurrence</i> besteht aus zwei Ziffern, die mit einem Schrägstrich vom Feldnamen abgetrennt sind. Das $-Zeichen trennt die einzelnen Unterfelder in einem Datenfeld ab. Das erste Zeichen hinter dem $-Zeichen ist der Name des Unterfelds, die restlichen Zeichen sind der eigentliche Inhalt des Unterfelds:<a class="Footnote" href="#picaSpecialChars" id="picaSpecialCharsRef"></a>
</p>

<section class="Footnote">
	<p><a href="#picaSpecialCharsRef" id="picaSpecialChars"></a>Die genannten Sonderzeichen für die Kennzeichnung von Feldern und Unterfeldern werden für die Darstellung in PICA-Systemen verwendet. In den eigentlichen Daten werden stattdessen die Zeichen <dfn>Field Separator</dfn> und <dfn>Subfield Separator</dfn> mit den Zeichencodes <i>0x1f</i> und <i>0x1e</i>.
	</p>
</section>

<pre class="Example">
003@ $0123
021A $0
028A/01
028A/02
TODO: Beispiel kompletieren
</pre>

<p>Um diesen Datensatz mit Metamorph verarbeiten zu können, müssen wir die Feld-Unterfeld-Struktur des PICA+ Formats mit den Strukturelementen des Metamorph-Datenmodells nachbilden. Das PICA+ Format besitzt drei Strukturelemente: Datensatz, Feld und Unterfeld. Diese Elemente können wie folgt auf das Metamorph-Datenmodell abgebildet werden:
</p>

<ul>
	<li>Der <strong>PICA+ Datensatz</strong> findet eine direkte Entsprechung im Datensatz des Metamorph-Datenmodells. Als Datensatz-Identifikator kann der Inhalt des Unterfelds 003@$0 verwendet werden. In diesem Unterfeld steht bei PICA+ gängigerweise eine eindeutige Datensatznummer.</li>

	<li>Ein <strong>PICA+ Feld</strong> hat einen Namen und gruppiert ein oder mehrere Unterfelder. Dies können wir mit einer Entität nachbilden. Die ggf. vorhandenen Angaben zu <i>Occurrences</i> benötigen wir nicht, da die Reihenfolge der Entitäten im Metamorph-Datenmodell immer beachtet wird. Wir betrachten die <i>Occurrence</i> daher einfach als Teil des Feldnamens. Alternativ wäre es auch möglich, sie vom Feldnamen abzuschneiden und zu verwerfen.</li>

	<li>Ein <strong>Unterfeld</strong> ist einfach ein Pärchen von Namen und Datenwert, wir können es also einfach als ein Literal darstellen.</li>
</ul>

<p>Im Metamorph-Datenmodell sieht der obige Datensatz dann so aus:
</p>

<div class="RecordSet">
	<div class="Record">
		<span class="RecordId">Datensatz mit Id &ldquo;123&rdquo;</span>
		<dl>
			<dt class="Entity">003@</dt>
			<dd>
				<dl>
					<dt>0</dt><dd>123</dd>
				</dl>
			</dd>
			<dt class="Entity">021A</dt>
			<dd>
				<dl>
					<dt>0</dt><dd>Titel</dd>
				</dl>
			</dd>
		</dl>
	</div>
</div>

<p>Das Beispiel zeigt, dass sich außer den Strukturelementen zur Gliederung des Datensatzes durch die Umwandlung ins Metamorph-Datenmodell nichts an dem Datensatz geändert hat, was seine Bedeutung verändert. Die Strukturelemente des PICA+ Formats lassen sich eins zu eins auf die Strukturelemente des Metamorphdatenmodells abbilden.</p>

<p>Umgkehrt ist dies allerdings nicht der Fall: Im Metamorph-Datenmodell können Datenstrukturen aufgebaut werden, die sich nicht in PICA+ serialisieren lassen. So ist es bspw. nicht möglich, Strukturen mit verschachtelten Entitäten nach PICA+ zu serialisieren, da das Format nur eine Hierarchieebene (Felder und Unterfelder) kennt. Darüber hinaus sind die erlaubten Feld- und Unterfeldnamen stark beschränkt, sodass ein Entitätsname wie &ldquo;author&rdquo; nicht als Feldname verwendet werdem kann. Aus diesem Grund kann eine Abbildung vom Metamorph-Datenmodell auf PICA+ nur auf einer Teilmenge des Metamorph-Datenmodells definiert werden. Diese Teilmenge umfasst sinnvollerweise nur Datenstrukturen, die auf der Datensatzebene nur aus Entitäten bestehen, die dann wiederum nur Literale enthalten. Die Namen der Entitäten müssen den Regeln für PICA+ Feldnamen entsprechen und die Literalnamen dürfen nur aus einem alphanumerischen Zeichen bestehen. Daten, die im Metamorph-Datenmodell nicht dieser Struktur entsprechen, können nicht im PICA+ Format serialisiert werden.
</p>

<p>Auf die gleich Art und Weise wie das PICA+ Format können auch andere Datenformate mit denen im bibliothekarischen Bereich üblichen Feld-Unterfeldstrukturen ins Metamorph-Datenmodel und wieder zurück übertragen werden. Unterschiedliche Details der Datenformate erfordern dabei natürlich spezifische Anpassungen.
</p>

<h4 id="exampleJson">Darstellung von JSON im Metamorph-Datenmodell</h4>

<h4>Darstellung von XML im Metamorph-Datenmodell</h4>

<p>XML ist ein weit verbreitetes Datenformat, das in vielen Bereichen eingesetzt wird. Um XML-Daten im Metamorph-Datemodell darzustellen, gibt es zwei Möglichkeiten:
</p>

<ol>
	<li>Zum einen kann eine <strong>allgemeine Abbildung</strong> definiert werden, die festlegt, wie Elemente, Attribute und Text aus XML mit den Strukturelementen des Metamorph-Datenmodells modelliert werden können, ohne dabei auf die Eigenheiten bestimmter XML-Schemata einzugehen.</li>
	<li>Zum anderen kann eine Abbildung aber auch Schemainformationen zu einem XML-Datenformat gezielt nutzen, um eine <strong>optimal angepasste Abbildung</strong> dieses Formats im Metamorph-Datenmodell zu definieren.</li>
</ol>

<p>Während der erste Ansatz den Vorteil hat, jedes beliebige XML-Datenformat im Metamorph-Datenmodell darstellen zu können, hat er den Nachteil, dass die entstehende Struktur sich nicht immer gut weiterverarbeiten lässt. Dies betrifft z.&thinsp;B. Formate wie MAB- oder MARC-XML, die generische Element- und Attributnamen verwenden und die eigentlichen Feldbezeichnungen als Attributwerte oder Textinhalt ablegen, wie der folgende Ausschnitt aus einem MARC-XML-Dokument zeigt:
</p>

<code><![CDATA[

]]></code>

<p>Bei der Abbildung dieses Formats auf das Metamorph-Datenmodell werden die Attribut- und Elementnamen zu Entitäts- und Literalnamen. Die eigentlich für die Arbeit relevanten Feldbezeichner werden hingegen zu Literalwerten. Das erschwert das Auswählen von Datenwerten anhand der Feldbezeichner deutlich und macht das zu Anfang des Kapitels beschriebene Grundkonzept des Metamorph-Datenmodells wirkungslos, Literal- und Entitätsnamen zur einfachen Auswahl von Datenwerten zu verwenden.
</p>

<p>In diesem Abschnitt wird eine allgemeine Abbildung von XML-Daten auf das Metamorph-Datenmodell vorgestellt. <!-- Hier könnte auf die Mf-Module GenericXmlDecoder und SimpleXmlEncoder verwiesen werden: Diese sind in den Metafacturemodulen GenericXmlDecoder und SimpleXmlEncoder umgesetzt. --> Diese funktioniert mit allen XML-Datenformaten, hat aber die oben genannten Nachteile. Bei der Arbeit mit XML-Formaten wie dem aus dem obigen Beispiel ist es sinnvoll, statt der allgemeinen Abbildung formatspezifische Abbildungen zu definieren, die die zur Selektion genutzten Datenwerte als Literal- und Entitätsnamen verwenden.
</p>

<p>Zum Einstieg in die Beschreibung der Abbildung stellen wir kurz noch einmal die relevanten Aspekte des XML-Formats vor. Den Kern von XML bilden Elemente bzw. Tags. Diese werden in spitzen Klammern geschrieben und dienen dem Aufbau der grundlegenden Datenstruktur. Elemente können beliebig verschachtelt werden. Jedes XML-Dokument hat dabei genau ein äußerstes Element, das als Wurzelelement bezeichnet wird. Elemente können leer sein oder aus einem öffnenden und schließenden Tag bestehen:
</p>

<code><![CDATA[

]]></code>

<p>Neben verschachtelten Elementen können Elemente auch einfachen Text enthalten, dieser kann sich mit Elementen abwechseln, wie das folgende Beispiel zeigt:
</p>

<code><![CDATA[

]]></code>

<p>Darüber hinaus können zusätzliche Informationen zu einem Element auch als Attribut im Element angegeben werden. Dabei handelt es sich um Schlüssel-Wert-Paare, die hinter dem Elementnamen innerhalb der spitzen Klammern angegeben sind:
</p>

<code><![CDATA[

]]></code>

<h4>Darstellung von RDF im Metamorph-Datenmodell</h4>

<p>Im Gegensatz zu RDF verwendet Metamorph ein etwas einfacheres Datenmodell und behält das Konzept des Datensatzes bei, dass es in RDF so nicht mehr gibt. Der Grund dafür ist, das sich in der täglichen Arbeit mit Daten zeigt, dass diese häufig in einer wohldefinierten Zusammenstellung benötigt werden und nicht nur in einem weitläufigen Netz.
</p>

<p>Diese Trennung der verschiedenen Aspekte der Datenbeschreibung findet sich in RDF wieder. RDF kann in verschiedenen Formaten serialisiert werden (u.&thinsp;a. RDF-XML und Turtle), es definiert eine allgemeine Datenstruktur (das RDF-Graphmodell) und es gibt Vokabulare bzw. Ontologien, die konkrete Namen und Strukturen definieren, um Domänenwissen in RDF zu beschreiben.
</p>

<h2>Zusammenfassung</h2>

<p>Das Metamorph-Datenmodell geht also davon aus, dass für die Arbeit mit Daten drei Dinge notwendig sind:
</p>

<ol>
    <li>Das Datenformat: in welcher Form werden die Daten abgespeichert, eingegeben oder angezeigt?</li>
    <li>Die Datenstruktur: welche Möglichkeiten gibt es zur Strukturierung der Daten?</li>
    <li>Das Vokabular: wie sind einzelne Datenelemente benannt und wie werden sie konkret strukturiert?</li>
</ol>

<ol>
    <li>Einfache Datenwerte werden als &ndash; Literale genannte &ndash; Schlüssel-Wert-Paare dargestellt.</li>
    <li>Literale können wiederholt werden. Im Datenmodell ist festgelegt, dass Literallisten geordnet sind.</li>
    <li>Komplexe Informationen werden mit Entitäten dargestellt. Eine Entität ist eine geordnete und benannte Menge von Literalen und anderen Entitäten.</li>
    <li>Komplexe Informationen werden mit Entitäten dargestellt. Eine Entität ist eine geordnete und benannte Menge von Literalen und anderen Entitäten.</li>
    <li>Literal- und Entitätsnamen sind nicht vergegeben. Es können beliebige Texte verwendet werden. Das Metamorph-Datenmodell legt nur die Struktur der Daten fest. Es macht keine Vorgaben zu dem verwendeten Vokabular.</li>
</ol>

<footer>
<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Lizenzvertrag" style="border-width:0" src="http://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a>
<span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" property="dct:title" rel="dct:type">Metafacture und Metamorph</span> von <a xmlns:cc="http://creativecommons.org/ns#" href="https://bitbucket.org/chrisboehme" property="cc:attributionName" rel="cc:attributionURL">Christoph Böhme</a> ist lizenziert unter einer <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Namensnennung - Weitergabe unter gleichen Bedingungen 4.0 International Lizenz</a>.
</footer>

</body>
</html>